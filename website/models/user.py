from typing import Any

import re
import secrets
import uuid
from sqlalchemy import func
from urllib.parse import urlparse
from datetime import datetime

import pyotp
from pyotp.totp import TOTP
from flask import url_for
from flask_login import UserMixin  # type: ignore[import-untyped]
from sqlalchemy.orm import validates
from the_big_username_blacklist import validate  # type: ignore[import-untyped]
from sqlalchemy.dialects.postgresql import UUID
from validate_email import validate_email  # type: ignore[import-untyped]
from werkzeug.security import check_password_hash

from website.models import Bundle
from website.models import Comment
from website.web.bootstrap import db
from website.web.bootstrap import application


def generate_token() -> str:
    return secrets.token_urlsafe(64)


class User(db.Model, UserMixin):  # type: ignore[name-defined, misc]
    """
    Represent a user. Logins and api keys are unique, emails addresses are not.
    """

    id = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(
        UUID(as_uuid=True), default=uuid.uuid4, unique=True, nullable=False
    )
    login = db.Column(db.String(30), unique=True, nullable=False)
    name = db.Column(db.String(50), nullable=False)
    email = db.Column(db.String(256), nullable=False)
    pwdhash = db.Column(db.String(), nullable=False)
    secret_token = db.Column(db.String(), unique=True)  # for Two-Factor Authentication
    is_two_factor_authentication_enabled = db.Column(
        db.Boolean, nullable=False, default=False
    )

    organisation = db.Column(db.String(50), default="")
    country_code = db.Column(db.String(3), default="")  # for alpha-3 codes
    bio = db.Column(db.String(5000), default="")
    webpage = db.Column(db.String(2048), default="")
    mastodon = db.Column(db.String(500), default="")
    github = db.Column(db.String(39), default="")
    linkedin = db.Column(db.String(30), default="")

    created_at = db.Column(db.DateTime(), default=datetime.now)
    last_seen = db.Column(db.DateTime(), default=datetime.now)

    apikey = db.Column(db.String(100), default=generate_token, unique=True)

    is_active = db.Column(db.Boolean(), default=True)
    is_confirmed = db.Column(db.Boolean(), default=False)

    # user rights
    is_admin = db.Column(db.Boolean(), default=False)
    is_commenter = db.Column(db.Boolean(), default=True)
    is_reporter = db.Column(db.Boolean(), default=False)

    # relationships
    comments = db.relationship("Comment", backref="author", lazy="dynamic")
    bundles = db.relationship("Bundle", backref="author", lazy="dynamic")
    sightings = db.relationship("Sighting", backref="author", lazy="dynamic")

    def __init__(self, **kwargs: Any):
        super().__init__(**kwargs)
        if self.secret_token is None:
            self.secret_token = pyotp.random_base32()

    def get_id(self) -> int:
        """
        Return the id of the user.
        """
        return self.id

    def check_password(self, password: str) -> bool:
        """
        Check the password of the user.
        """
        return check_password_hash(self.pwdhash, password)

    def generate_apikey(self) -> str:
        self.apikey = generate_token()
        return self.apikey

    def __str__(self) -> str:
        return str(self.uuid)

    @validates("login")
    def validates_login(self, key: str, value: str) -> str:
        assert 3 <= len(value) <= 30, AssertionError("Maximum length for login: 30")
        if value != "admin":
            assert validate(value), AssertionError("Username not allowed.")
        return re.sub("[^a-zA-Z0-9_-]", "", value.strip())

    @validates("email")
    def validates_email(self, key: str, value: str) -> str:
        assert 3 <= len(value) <= 256, AssertionError("Maximum length for email: 256")
        assert validate_email(value), AssertionError("Email address not valid")
        return value

    @validates("name")
    def validates_name(self, key: str, value: str) -> str:
        assert 3 <= len(value) <= 50, AssertionError("Maximum length for name: 50")
        value = value.strip()
        return value

    @validates("bio")
    def validates_bio(self, key: str, value: str) -> str:
        if not self.is_admin:
            assert 0 <= len(value) <= 5000, AssertionError(
                "Maximum length for bio: 5000"
            )
            value = value.strip()
            # Remove external links
            value = re.sub(r"\[.*?\]\(http[s]?://[^\)]+\)", "", value)
        # Remove images
        value = re.sub(r"!\[.*?\]\(.*?\)", "", value)
        return value

    @validates("country_code")
    def validates_country_code(self, key: str, value: str) -> str:
        assert 0 <= len(value) <= 3, AssertionError(
            "Maximum length for country_code: 3"
        )
        value = value.strip()
        return value

    @validates("organisation")
    def validates_organisation(self, key: str, value: str) -> str:
        assert 0 <= len(value) <= 50, AssertionError(
            "Maximum length for organisation: 50"
        )
        return re.sub("[^a-zA-Z0-9_-]", "", value.strip())

    @validates("github")
    def validates_github(self, key: str, value: str) -> str:
        assert 0 <= len(value) <= 39, AssertionError("Maximum length for GitHub: 39")
        if value.strip():
            github_regex = r"^[a-zA-Z\d](?:[a-zA-Z\d]|-(?=[a-zA-Z\d])){0,38}$"
            assert re.match(github_regex, value) is not None, AssertionError(
                "Invalid GitHub username."
            )
        return value

    @validates("linkedin")
    def validates_linkedin(self, key: str, value: str) -> str:
        assert 0 <= len(value) <= 30, AssertionError("Maximum length for LinkedIn: 30")
        if value.strip():
            linkedin_regex = r"^[a-zA-Z\d](?:[a-zA-Z\d-]{0,28}[a-zA-Z\d])?$"
            assert re.match(linkedin_regex, value) is not None, AssertionError(
                "Invalid LinkedIn username."
            )
        return value

    @validates("apikey")
    def validates_apikey(self, key: str, value: str) -> str:
        assert 30 <= len(value) <= 100, AssertionError("Minimum length for apikey: 30")
        return value

    @staticmethod
    def make_valid_login(login: str) -> str:
        return re.sub("[^a-zA-Z0-9_-]", "", login)

    def get_authentication_setup_uri(self) -> str:
        """Returns the authentication URI for the Two-Factor Authentication as a string."""
        image_url = url_for("static", filename="favicon.ico", _external=True)
        image_uri = urlparse(image_url)
        if image_uri.scheme != "https":
            image_url = ""
        return pyotp.totp.TOTP(self.secret_token).provisioning_uri(
            name=self.login, issuer_name=application.config["APP_NAME"], image=image_url
        )

    def is_otp_valid(self, user_otp: Any) -> bool:
        """Checks the validity of a One Time password."""
        totp: TOTP = pyotp.parse_uri(self.get_authentication_setup_uri())  # type: ignore
        return totp.verify(user_otp)

    def nb_contributions(self) -> int:
        """Returns the number of contributions (creation of comments and bundles) of the user."""
        # Subquery for counting comments
        comment_count = (
            db.session.query(func.count(Comment.uuid))
            .filter(Comment.author_id == self.id)
            .scalar()
        )

        # Subquery for counting bundles
        bundle_count = (
            db.session.query(func.count(Bundle.uuid))
            .filter(Bundle.author_id == self.id)
            .scalar()
        )

        # Sum the counts
        total_contributions = (comment_count or 0) + (bundle_count or 0)

        return total_contributions

    def permissions(self) -> list[str]:
        """Returns the list of persmissions of the user.
        A: Admin, C: Commenter, R: Reporter."""
        user_permissions = []
        if self.is_admin:
            user_permissions.append("A")
        if self.is_commenter:
            user_permissions.append("C")
        if self.is_reporter:
            user_permissions.append("R")
        return user_permissions
