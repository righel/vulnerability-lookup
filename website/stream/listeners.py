from typing import Any

import threading
import json
from datetime import datetime, timezone

from flask import url_for
from sqlalchemy import event
from sqlalchemy.engine import Connection
from sqlalchemy.event import remove
from sqlalchemy.inspection import inspect
from sqlalchemy.orm import Mapper

from vulnerabilitylookup.default import get_config
from website.models import Comment, Bundle, Sighting
from website.web.bootstrap import vulnerabilitylookup


def publish_in_background(channel: str, message: str) -> None:
    """Offload the publishing logic to a background thread to avoid blocking the database transaction."""
    threading.Thread(
        target=vulnerabilitylookup.redis_client.publish, args=(channel, message)
    ).start()


def stream_comment(mapper: Mapper, connection: Connection, target: Any) -> None:  # type: ignore[type-arg]
    """
    Called after a new Comment instance is inserted into the database.
    """
    # Convert the object to a dictionary or JSON string
    message = {
        "payload": {
            column.key: getattr(target, column.key)
            for column in inspect(target).mapper.column_attrs
        },
        "instance_uuid": get_config("generic", "local_instance_uuid").lower(),
        "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "data_type": "comment",
        "uri": url_for("comment_bp.get", comment_uuid=target.uuid, _external=True),
    }
    # Publish to the channel
    publish_in_background("comment", json.dumps(message))


def stream_bundle(mapper: Mapper, connection: Connection, target: Any) -> None:  # type: ignore[type-arg]
    """
    Called after a new Bundle instance is inserted into the database.
    """
    # Convert the object to a dictionary or JSON string
    message = {
        "payload": {
            column.key: getattr(target, column.key)
            for column in inspect(target).mapper.column_attrs
        },
        "instance_uuid": get_config("generic", "local_instance_uuid").lower(),
        "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "data_type": "bundle",
        "uri": url_for("bundle_bp.get", bundle_uuid=target.uuid, _external=True),
    }
    # Publish to the channel
    publish_in_background("bundle", json.dumps(message))


def stream_sighting(mapper: Mapper, connection: Connection, target: Any) -> None:  # type: ignore[type-arg]
    """
    Called after a new Sighting instance is inserted into the database.
    """
    # Convert the object to a dictionary or JSON string
    message = {
        "payload": {
            column.key: getattr(target, column.key)
            for column in inspect(target).mapper.column_attrs
        },
        "instance_uuid": get_config("generic", "local_instance_uuid").lower(),
        "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "data_type": "sigthing",
        "uri": f"{url_for('home_bp.vulnerability_view', vulnerability_id=target.vulnerability, _external=True)}#sightings",
    }
    # Publish to the channel
    publish_in_background("sighting", json.dumps(message))


# Registry of events required for unregistering listeners
event_registry = {
    "comment": (Comment, "after_insert", stream_comment),
    "bundle": (Bundle, "after_insert", stream_bundle),
    "sighting": (Sighting, "after_insert", stream_sighting)

}

def register_listeners() -> None:
    """Register the listeners."""
    for channel in get_config("stream", "channels"):
        if channel in event_registry:
            target, identifier, listener = event_registry[channel]
            event.listen(target, identifier, listener)


def remove_all_listeners() -> None:
    from sqlalchemy.event import remove

    # Remove all registered listeners
    for model, event_name, listener in event_registry:
        try:
            remove(model, event_name, listener)
            print("listener removed")
        except Exception:
            print("no listener")
            continue

    # Clear the registry
    event_registry.clear()


# def remove_all_listeners_for_event(model, event_name) -> None:
#     try:
#         # Loop through all listeners and remove them
#         while True:
#             remove(model, event_name)
#     except ValueError:
#         # Raised when there are no more listeners to remove
#         pass


# def remove_all_listeners_for_model(model) -> None:
#     event_names = [
#         "before_insert",
#         "after_insert",
#         "before_update",
#         "after_update",
#         "before_delete",
#         "after_delete",
#     ]
#     for event_name in event_names:
#         remove_all_listeners_for_event(model, event_name)
