#!/usr/bin/env python3


import click
import os
import subprocess
import sys
from datetime import datetime, timezone

from pymispwarninglists import tools

import website.models
import website.scripts
from vulnerabilitylookup.default import get_homedir, safe_create_dir
from website.models import User
from website.web.bootstrap import application, db


@application.cli.command("db_init")
def db_init() -> None:
    "Will create the database from conf parameters."
    with application.app_context():
        website.models.db_init(db)


@application.cli.command("db_create")
def db_create() -> None:
    "Will create the database."
    with application.app_context():
        website.models.db_create(
            db,
            application.config["DB_CONFIG_DICT"],
            application.config["DATABASE_NAME"],
        )


@application.cli.command("db_backup")
def db_backup() -> None:
    "Will backup the database."
    with application.app_context():
        homedir = get_homedir()
        db_name = application.config["DATABASE_NAME"]

        # Set up the environment variables for pg_dump
        os.environ["PGPASSWORD"] = application.config["DB_CONFIG_DICT"]["password"]

        # Construct the backup filename with timestamp
        safe_create_dir(homedir / "dumps")
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        backup_file = os.path.join(
            homedir, "dumps", f"{db_name}_backup_{timestamp}.sql"
        )

        # Construct the pg_dump command
        command = [
            "pg_dump",
            "-U",
            application.config["DB_CONFIG_DICT"]["user"],
            "-h",
            application.config["DB_CONFIG_DICT"]["host"],
            "-p",
            str(application.config["DB_CONFIG_DICT"]["port"]),
            "-F",
            "c",  # Custom format
            "-f",
            backup_file,
            db_name,
        ]

        try:
            # Run the pg_dump command
            subprocess.run(command, check=True)
            print(f"Database backup completed successfully: {backup_file}")
        except subprocess.CalledProcessError as e:
            print(f"Error during backup: {e}")
        finally:
            # Clean up the environment variable
            os.environ.pop("PGPASSWORD", None)


@application.cli.command("create_user")
@click.option("--login", default="admin", help="Login")
@click.option("--email", default="admin@admin.localhost", help="Email")
@click.option("--password", default="password", help="Password")
def create_user(login: str, email: str, password: str) -> None:
    "Initializes a user."
    print(f"Creation of the user {login}…")
    with application.app_context():
        website.scripts.create_user(
            login,
            email,
            password,
            True,
            True,
            False,
            False,
        )


@application.cli.command("create_admin")
@click.option("--login", default="admin", help="Login")
@click.option("--email", default="admin@admin.localhost", help="Email")
@click.option("--password", default="password", help="Password")
def create_admin(login: str, email: str, password: str) -> None:
    "Initializes an admin user."
    print(f"Creation of the admin user {login}…")
    with application.app_context():
        website.scripts.create_user(
            login,
            email,
            password,
            True,
            True,
            True,
            True,
        )


@application.cli.command("user_get_api_key")
@click.option("--login", default="admin", help="Login")
def user_get_api_key(
    login: str,
) -> None:
    "Returns the API key of a user."
    user = User.query.filter(User.login == login).first()
    print(user.apikey)


@application.cli.command("user_list")
def user_list() -> None:
    """List all users."""
    for user in User.query.all():
        print(user)
        print()


@application.cli.command("user_delete")
@click.option("--login", default="", help="Login of the user to delete.")
@click.option(
    "-y",
    "--yes",
    is_flag=True,
    help="Automatically reply yes to the confirmation message.",
)
def user_delete(login: str, yes: str) -> None:
    """Delete the user specified with its login."""
    if yes or click.confirm("Delete the user?"):
        try:
            user = User.query.filter(User.login == login).first()
            if user:
                db.session.delete(user)
                db.session.commit()
            else:
                print("No such user.", file=sys.stderr)
        except Exception as e:
            print(e)


@application.cli.command("update_warninglists")
def update_warninglists() -> None:
    """Update MISP warning lists."""
    homedir = get_homedir()
    homedir = homedir.joinpath("data")
    safe_create_dir(homedir)
    os.environ["XDG_DATA_HOME"] = homedir.absolute().as_posix()
    tools.update_warninglists()  # type: ignore[no-untyped-call]
    print(f"Warning lists updated successfully: {homedir}")
