#!/usr/bin/env python3

import re
import hashlib
import json
from datetime import datetime
from dateutil.parser import parse  # type: ignore[import-untyped]
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

from typing import Any, Dict

import cvss  # type: ignore[import-untyped]
import markdown  # type: ignore[import-untyped]


def is_url(value: str) -> bool:
    url_pattern = re.compile(
        r"^(https?:\/\/)?"  # optional scheme
        r"(([a-zA-Z\d-]+\.)+[a-zA-Z]{2,}|localhost|"  # domain or localhost
        r"(\d{1,3}\.){3}\d{1,3})"  # or IP address
        r"(:\d+)?"  # optional port
        r"(\/[-a-zA-Z\d%_.~+]*)*"  # path
        r"(\?[;&a-zA-Z\d%_.~+=-]*)?"  # query string
        r"(\#[-a-zA-Z\d_]*)?$",  # fragment locator
        re.IGNORECASE,
    )
    return re.match(url_pattern, value) is not None


def str_to_obj(str: str) -> Dict[str, Any]:
    """Returns a Python object from a (JSON) string."""
    try:
        return json.loads(str)
    except Exception:
        return {"message": "Error when deserializing the string."}


def datetimeformat(value: datetime, format: str = "%Y-%m-%d %H:%M") -> str:
    """Converts a datetime obect to a formatted string."""
    return value.strftime(format)


def string_to_datetime(value: str, format: str = "") -> str:
    """Converts the format of a formatted string."""
    now = datetime.now()
    try:
        new_date_time = parse(value)
    except Exception:
        return value
    if format:
        return datetimeformat(new_date_time, format)
    elif new_date_time.year == now.year and new_date_time.month == now.month:
        return datetimeformat(new_date_time, "%d")
    elif new_date_time.year == now.year:
        return datetimeformat(new_date_time, "%b %d")
    else:
        return datetimeformat(new_date_time)


def to_markdown(value: str) -> str:
    """Converts a markdown string to HTML."""
    try:
        return markdown.markdown(value)
    except Exception:
        return value


def hash(value: str) -> str:
    """Returns a hexadecimal SHA 256 hash of the input value."""
    m = hashlib.sha256()
    m.update(value.encode())
    return m.hexdigest()


def cvss_base_score(vector: str, version: str) -> str:
    """Returns the base code from a CVSS vector."""
    if version in ["cvssV4_0", "CVSS_V4", "cvssV4_0"]:
        c = cvss.CVSS4(vector)
        return str(c.base_score)
    elif version in ["cvssV3_0", "CVSS_V3", "cvssV3_1"]:
        c = cvss.CVSS3(vector)
        return ", ".join(
            [str(score) for score in c.scores()[:1]]
        )  # slice the list to ignore temporal and environmental scores
    return vector


def cvss_severity(vector: str, version: str) -> str:
    """Returns the severity from a CVSS vector."""
    if version in ["cvssV4_0", "CVSS_V4", "cvssV4_0"]:
        c = cvss.CVSS4(vector)
        return str(c.severity)
    elif version in ["cvssV3_0", "CVSS_V3", "cvssV3_1"]:
        c = cvss.CVSS3(vector)
        return ", ".join(
            [str(score) for score in c.severities()[:1]]
        )  # slice the list to ignore temporal and environmental scores
    return vector


def cvss_clean_vector(vector: str, version: str) -> str:
    """Returns a clean version of a vector."""
    if version in ["cvssV4_0", "CVSS_V4", "cvssV4_0"]:
        c = cvss.CVSS4(vector)
        return c.clean_vector()
    elif version in ["cvssV3_0", "CVSS_V3", "cvssV3_1"]:
        c = cvss.CVSS3(vector)
        return c.clean_vector()
    return vector


def update_query_params(url: str, **new_params: str) -> str:
    """
    Update or add query parameters to a given URL.

    This function parses the input URL, extracts its query parameters, and
    updates them with the new parameters provided in `new_params`. If a
    parameter already exists in the URL, its value is replaced. This ensures
    that no duplicate query parameters are added to the URL.

    Args:
        url (str): The URL to be updated.
        **new_params: Arbitrary keyword arguments representing the query
                      parameters to be added or updated in the URL.

    Returns:
        str: The updated URL with the new query parameters.
    """
    # Parse the URL and extract its components
    url_parts = urlparse(url)

    # Parse the query string into a dictionary (parse_qs returns lists for values)
    query_params: Dict[str, str] = {
        key: value[0] for key, value in parse_qs(url_parts.query).items()
    }

    # Update with the new parameters (this will replace any existing ones)
    query_params.update(new_params)

    # Reconstruct the URL with updated query parameters
    updated_query: str = urlencode(query_params)
    new_url: str = urlunparse(url_parts._replace(query=updated_query))

    return new_url
