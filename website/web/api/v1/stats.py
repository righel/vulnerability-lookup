from typing import Any
from typing import Union

import logging
from flask import make_response
from flask_restx import Namespace  # type: ignore[import-untyped]
from flask_restx import Resource
from flask_restx import reqparse
from flask_restx.inputs import date_from_iso8601  # type: ignore[import-untyped]
from sqlalchemy import func, distinct
from werkzeug import Response as WerkzeugResponse

from website.models import Comment
from website.models import Sighting
from website.web.bootstrap import db


logger = logging.getLogger(__name__)

stats_ns = Namespace("stats", description="Endpoint for retrieving various statistics.")


# Argument Parsing
parser_sighting = reqparse.RequestParser()
parser_sighting.add_argument(
    "date_from",
    type=date_from_iso8601,
    required=False,
    help="The date of the sightings must be bigger or equal than this value. Format: YYYY-MM-DD",
)
parser_sighting.add_argument(
    "date_to",
    type=date_from_iso8601,
    required=False,
    help="The date of the sightings must be smaller or equal than this value. Format: YYYY-MM-DD",
)
parser_sighting.add_argument(
    "sighting_type",
    type=str,
    default="",
    choices=(
        "seen",
        "exploited",
        "not-exploited",
        "confirmed",
        "not-confirmed",
        "patched",
        "not-patched",
    ),
    help="The type of the sighting.",
)
parser_sighting.add_argument(
    "limit",
    type=int,
    default=10,
    help="The top elements to take into account in the query.",
)
parser_sighting.add_argument(
    "output",
    type=str,
    default="json",
    choices=("json", "markdown"),
    help="The format of the output.",
)


parser = reqparse.RequestParser()
parser.add_argument(
    "date_from",
    type=date_from_iso8601,
    required=False,
    help="The date of the sightings must be bigger or equal than this value. Format: YYYY-MM-DD",
)
parser.add_argument(
    "date_to",
    type=date_from_iso8601,
    required=False,
    help="The date of the sightings must be smaller or equal than this value. Format: YYYY-MM-DD",
)
parser.add_argument(
    "limit",
    type=int,
    default=10,
    help="The top elements to take into account in the query.",
)
parser.add_argument(
    "output",
    type=str,
    default="json",
    choices=("json", "markdown"),
    help="The format of the output.",
)


def generate_markdown_table(data: list[dict[str, Any]]) -> str:
    """
    Generate a Markdown table from a list of dictionaries containing vulnerabilities and their counts.

    :param data: List of dictionaries with 'vulnerability' and 'count' keys.
    :return: A string containing the Markdown table.
    """
    if not data:
        return "No data available."

    # Table headers
    headers = ["Vulnerability", "Count"]
    markdown_table = f"| {' | '.join(headers)} |\n"
    markdown_table += f"| {' | '.join(['-' * len(h) for h in headers])} |\n"

    # Table rows
    for item in data:
        markdown_table += f"| {item['vulnerability']} | {item['count']} |\n"

    return markdown_table


@stats_ns.route("/vulnerability/most_sighted")
class VulnerabilityMostSighted(Resource):  # type: ignore[misc]
    @stats_ns.doc(description="Returns the most sighted vulnerabilities.")  # type: ignore[misc]
    @stats_ns.expect(parser_sighting)  # type: ignore[misc]
    def get(self) -> Union[list[dict[str, Any]], str] | WerkzeugResponse:
        args = parser_sighting.parse_args()
        date_from = args.get("date_from")
        date_to = args.get("date_to")
        sighting_type = args.get("sighting_type")
        limit = args.get("limit")
        output = args.get("output")

        if limit > 100:
            limit = 100

        query = db.session.query(
            func.lower(Sighting.vulnerability).label(
                "vulnerability"
            ),  # Case-insensitive grouping
            func.count(distinct(Sighting.uuid)).label("sightings_count"),
        )

        if sighting_type:
            query = query.filter(Sighting.type == sighting_type)
        if date_from:
            query = query.filter(
                func.date(Sighting.creation_timestamp) >= date_from,
            )
        if date_to:
            query = query.filter(
                func.date(Sighting.creation_timestamp) >= date_to,
            )

        query = query.group_by(
            func.lower(Sighting.vulnerability)
        )  # Group by case-insensitive vulnerability
        query = query.order_by(
            func.count(distinct(Sighting.uuid)).desc()
        )  # Order by count
        query = query.limit(limit)

        # Convert results to a list of dictionaries
        result = [
            {"vulnerability": r.vulnerability, "count": r.sightings_count}
            for r in query.all()
        ]
        if output == "markdown":
            response = make_response(generate_markdown_table(result), 200)
            response.mimetype = "text/plain"
            return response
        return result


@stats_ns.route("/vulnerability/most_commented")
class VulnerabilityMostCommented(Resource):  # type: ignore[misc]
    @stats_ns.doc(description="Returns the most commented vulnerabilities.")  # type: ignore[misc]
    @stats_ns.expect(parser)  # type: ignore[misc]
    def get(self) -> Union[list[dict[str, Any]], str] | WerkzeugResponse:
        args = parser.parse_args()
        date_from = args.get("date_from")
        date_to = args.get("date_to")
        limit = args.get("limit")
        output = args.get("output")

        if limit > 100:
            limit = 100

        query = db.session.query(
            func.lower(Comment.vulnerability).label(
                "vulnerability"
            ),  # Case-insensitive
            func.count(Comment.uuid).label("comments_count"),
        )
        if date_from:
            query = query.filter(
                func.date(Comment.creation_timestamp) >= date_from,
            )
        if date_to:
            query = query.filter(
                func.date(Comment.creation_timestamp) >= date_to,
            )

        query = query.group_by(
            func.lower(Comment.vulnerability)
        )  # Group by case-insensitive vulnerability
        query = query.order_by(
            func.count(distinct(Comment.uuid)).desc()
        )  # Order by count
        query = query.limit(limit)

        # Convert results to a list of dictionaries
        result = [
            {"vulnerability": r.vulnerability, "count": r.comments_count}
            for r in query.all()
        ]
        if output == "markdown":
            response = make_response(generate_markdown_table(result), 200)
            response.mimetype = "text/plain"
            return response
        return result
