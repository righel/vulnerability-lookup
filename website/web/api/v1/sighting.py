from typing import Any
from typing import Dict
from typing import Tuple
from datetime import date
from datetime import datetime
from datetime import timezone
from dateutil.relativedelta import relativedelta  # type: ignore[import-untyped]

import logging
import uuid
from flask_login import current_user  # type: ignore[import-untyped]
from flask_restx import fields  # type: ignore[import-untyped]
from flask_restx import abort
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource
from flask_restx.inputs import date_from_iso8601  # type: ignore[import-untyped]
from sqlalchemy import func

from vulnerabilitylookup.default import get_config
from website.web.bootstrap import db
from website.validators import validate_json
from website.web.api.v1.common import auth_func
from website.web.api.v1.common import metada_params_model
from website.web.api.v1.common import user_params_model
from website.web.api.v1.common import uuid_type
from website.web.api.v1.types import ResultType
from website.models import Sighting

logger = logging.getLogger(__name__)

sighting_ns = Namespace("sighting", description="sighting related operations")

local_instance_uuid = get_config("generic", "local_instance_uuid").lower()

# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument("uuid", type=uuid_type, help="UUID of the sighting.")
parser.add_argument(
    "type",
    type=str,
    choices=(
        "seen",
        "exploited",
        "not-exploited",
        "confirmed",
        "not-confirmed",
        "patched",
        "not-patched",
    ),
    help="""Type of sightings:
     - Seen: The vulnerability was mentioned, discussed, or seen somewhere by the user.
     - Exploited: This vulnerability was exploited and seen by the user reporting the sighting.
     - Not exploited: This vulnerability was not exploited or seen by the user reporting the sighting.
     - Confirmed: The vulnerability is confirmed from an analyst perspective.
     - Not confirmed: The user expresses doubt about the veracity of the vulnerability.
     - Patched: This vulnerability was successfully patched by the user reporting the sighting.
     - Not patched: This vulnerability was not successfully patched by the user reporting the sighting.""",
)
parser.add_argument(
    "vuln_id",
    type=str,
    help="Vulnerability related to the sighting.",
)
parser.add_argument(
    "author",
    type=str,
    help="Author of the sighting.",
)
parser.add_argument(
    "date_from",
    type=date_from_iso8601,
    required=False,
    help="The date of the sightings must be bigger or equal than this value.",
)
parser.add_argument(
    "date_to",
    type=date_from_iso8601,
    required=False,
    help="The date of the sightings must be smaller or equal than this value.",
)


# Response marshalling
sighting_params_model = {
    "uuid": fields.String(description="Sighting UUID.", readonly=True),
    # "vulnerability_lookup_origin": fields.String(
    #     description="UUID of the Vulnerability Lookup origin instance.",
    #     readonly=True,
    #     default=local_instance_uuid,
    # ),
    # "author": fields.String(description="Author of the sighting."),
    "creation_timestamp": fields.DateTime(
        description="Creation time of the sighting.", readonly=True
    ),
    "type": fields.String(description="Type of the sighting."),
    "source": fields.String(
        description="The source of the sighting (Fediverse status URI, link, tool, etc.)."
    ),
    "vulnerability": fields.String(description="Vulnerability id."),
}
sighting = sighting_ns.model("Sighting", sighting_params_model)
metadata = sighting_ns.model("metadata", metada_params_model)

sighting["author"] = fields.Nested(
    sighting_ns.model("User", user_params_model), readonly=True
)

sighting_list_fields = sighting_ns.model(
    "SightingsList",
    {
        "metadata": fields.Nested(
            metadata, description="Metada related to the result."
        ),
        "data": fields.List(
            fields.Nested(sighting, skip_none=True), description="List of sightings."
        ),
    },
)


@sighting_ns.route("/sighting/<string:sighting_uuid>")
class SightingItem(Resource):  # type: ignore[misc]
    @sighting_ns.doc(description="Get a sighting with its UUID.")  # type: ignore[misc]
    @sighting_ns.doc(
        responses={
            200: "Success.",
            404: "Sighting not found.",
        }
    )  # type: ignore[misc]
    @sighting_ns.marshal_with(sighting, skip_none=True)  # type: ignore[misc]
    def get(self, sighting_uuid: str) -> Tuple[dict[Any, Any], int]:
        result = Sighting.query.filter(Sighting.uuid == sighting_uuid).first()
        if not result:
            return {"message": "Sighting not found."}, 404
        return result, 200


@sighting_ns.route("/sighting/")
class SightingsList(Resource):  # type: ignore[misc]
    @sighting_ns.doc("list_sightings")  # type: ignore[misc]
    @sighting_ns.expect(parser)  # type: ignore[misc]
    @sighting_ns.marshal_list_with(sighting_list_fields)  # type: ignore[misc]
    def get(self) -> Tuple[ResultType, int]:
        """List all sightings."""
        args = parser.parse_args()
        offset = args.pop("page", 1) - 1
        limit = args.pop("per_page", 1000)
        date_from = args.get("date_from")
        date_to = args.get("date_to")
        uuid = args.pop("uuid", None)
        author = args.pop("author", None)
        vuln_id = args.pop("vuln_id", None)
        type = args.pop("type", None)

        if limit > 1000:
            limit = 1000
        if date_from is None:
            date_from = (date.today() - relativedelta(days=7)).strftime("%Y-%m-%d")
        if date_to is None:
            date_to = date.today().strftime("%Y-%m-%d")

        result: ResultType = {
            "data": [],
            "metadata": {
                "count": 0,
                "offset": offset,
                "limit": limit,
            },
        }

        results = []
        count = 0
        query = Sighting.query
        if uuid is not None:
            query = query.filter(Sighting.uuid == uuid)
        if author is not None:
            query = query.filter(Sighting.author.has(login=author))
        if vuln_id is not None:
            query = query.filter(Sighting.vulnerability.ilike(vuln_id))
        if type is not None:
            query = query.filter(Sighting.type == type)

        if date_from is not None and date_to is not None:
            query = query.filter(
                func.date(Sighting.creation_timestamp) >= date_from,
                func.date(Sighting.creation_timestamp) <= date_to,
            )
        query = query.order_by(Sighting.creation_timestamp.desc())
        total = query.count()
        query = query.limit(limit)
        results = query.offset(offset * limit)
        count = total

        result["data"] = results
        result["metadata"]["count"] = count

        return result, 200

    @sighting_ns.doc(description="Create a new sighting.")  # type: ignore[misc]
    @sighting_ns.doc(
        responses={
            201: "Success.",
            400: "JSON validation failed or incorrect payload to instantiate a sighting.",
        }
    )  # type: ignore[misc]
    @sighting_ns.expect(sighting)  # type: ignore[misc]
    @sighting_ns.marshal_list_with(sighting_list_fields, code=201)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[ResultType, int]:
        """Create a new sighting."""
        result: ResultType = {
            "data": [],
            "metadata": {
                "count": 0,
                "offset": 0,
                "limit": 10,
            },
        }

        current_time = datetime.now(timezone.utc)
        sighting = sighting_ns.payload
        sighting["uuid"] = sighting.get("uuid", str(uuid.uuid4()))
        sighting["vulnerability_lookup_origin"] = local_instance_uuid
        if sighting.get("creation_timestamp"):
            sighting["creation_timestamp"] = sighting["creation_timestamp"]
        else:
            sighting["creation_timestamp"] = current_time.strftime(
                "%Y-%m-%dT%H:%M:%S.%fZ"
            )

        if (
            sighting.get("source", False)
            and Sighting.query.filter(
                Sighting.vulnerability.ilike(sighting["vulnerability"]),
                Sighting.source == sighting["source"],
                # func.date(Sighting.creation_timestamp) == func.date(current_time),
            ).count()
            != 0
        ):
            return result, 400

        # Validate the JSON payload
        # try:
        #     validate_json(sighting, "sighting")
        # except Exception:
        #     logger.warning("JSON validation failed.")
        #     return abort(400, "JSON validation failed.")

        obj = Sighting.query.filter(Sighting.uuid == sighting["uuid"]).first()
        if obj:
            return abort(400, "Not possible to update a sighting.")
        else:
            # creation of a new sighting
            try:
                new_sighting = Sighting(**sighting, author_id=current_user.id)
                db.session.add(new_sighting)
                result["data"] = new_sighting
                result["metadata"]["count"] = 1
            except TypeError:
                return abort(400, "Sighting creation failed.")

        db.session.commit()
        return result, 201
