from typing import Any
from typing import Dict
from typing import Tuple
from datetime import datetime, timezone

import logging
import orjson
from flask_login import current_user  # type: ignore[import-untyped]
from flask import request
from flask_restx import abort  # type: ignore[import-untyped]
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource
from redis import Redis

from vulnerabilitylookup import __version__
from vulnerabilitylookup.default import get_config
from vulnerabilitylookup.helpers import fromisoformat_wrapper
from website.validators import validate_json
from website.web.api.v1.common import auth_func
from website.web.bootstrap import vulnerabilitylookup
from website.web.permissions import reporter_permission, admin_permission

logger = logging.getLogger(__name__)

local_instance_name = get_config("generic", "local_instance_name").lower()
local_instance_vulnid_pattern = get_config("generic", "local_instance_vulnid_pattern")

vulnerability_ns = Namespace(
    "vulnerability", description="Vulnerability related operations."
)

storage = Redis(
    host=get_config("generic", "storage_db_hostname"),
    port=get_config("generic", "storage_db_port"),
)

# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument(
    "with_meta",
    type=bool,
    default=False,
    help="Include metada.",
)


vulnerability_query_parser = reqparse.RequestParser()
vulnerability_query_parser.add_argument(
    "data",
    type=dict,
    location="json",
    help="The JSON data (CVE version 5 format) of the security advisory.",
)


@vulnerability_ns.route("/vulnerability/<string:vulnerability_id>")
@vulnerability_ns.route(
    "/cve/<string:vulnerability_id>",
    doc={
        "description": "Alias for /api/vulnerability/<string:vulnerability_id",
        "deprecated": True,
        "doc": False,
    },
)
class Vulnerability(Resource):  # type: ignore[misc]
    @vulnerability_ns.doc(description="Get a vulnerability.")  # type: ignore[misc]
    @vulnerability_ns.expect(parser)  # type: ignore[misc]
    def get(self, vulnerability_id: str) -> dict[str, Any] | None:
        with_meta = True if request.args.get("with_meta") else False
        return vulnerabilitylookup.get_vulnerability(
            vulnerability_id, with_meta=with_meta
        )

    @vulnerability_ns.doc(description="Delete a vulnerability from the local source.")  # type: ignore[misc]
    @vulnerability_ns.doc(
        responses={
            204: "Success.",
            403: "Admin permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def delete(self, vulnerability_id: str) -> Tuple[dict[Any, Any], int]:
        """Endpoint for deleting a vulnerability.
        We only accept to delete vulnerabilities from the local source."""
        source = (
            vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
            or local_instance_name
        )
        if source != local_instance_name:
            return abort(
                422,
                "You can only delete a vulnerability fron the source {}.".format(
                    local_instance_name
                ),
            )
        storage.delete(vulnerability_id)
        return {}, 204


@vulnerability_ns.route("/vulnerability/")
class VulnerabilitiesList(Resource):  # type: ignore[misc]
    @vulnerability_ns.doc(description="Create a vulnerability with the CVE version 5 format.")  # type: ignore[misc]
    @vulnerability_ns.doc(
        responses={
            200: "Success.",
            400: "JSON validation failed.",
            403: "Reporter permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @vulnerability_ns.expect(vulnerability_query_parser)  # type: ignore[misc]
    @reporter_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[Dict[Any, Any], int]:
        """Endpoint for creating and editing vulnerabilities in the local source."""
        ids: dict[str, float] = {}

        # Validate the JSON payload
        vuln = vulnerability_ns.payload
        if (
            not current_user.is_admin
        ):  # admins can submit non valid JSON for security advisories
            try:
                validate_json(vuln, "circl_vuln")
            except Exception:
                logger.warning("JSON validation failed.")
                abort(400, "JSON validation failed.")

        vuln_id = vuln["cveMetadata"].get("vulnId", "").lower()
        cve_id = vuln["cveMetadata"].get("cveId", "").lower() or None

        if not vuln_id:
            abort(
                400,
                "You must specify a vulnerability id to the format: {}.".format(
                    local_instance_vulnid_pattern
                ),
            )

        source = (
            vulnerabilitylookup.get_vulnerability_source(vuln_id) or local_instance_name
        )
        if source != local_instance_name:
            logger.warning(
                f"Not possible to edit a vulnerability from the source {source}."
            )
            abort(
                422,
                "You can not edit a vulnerability fron the source {}. You must change the vulnerability ID.".format(
                    source
                ),
            )

        now = datetime.now(timezone.utc)

        if "dateUpdated" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["dateUpdated"])
        elif "datePublished" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["datePublished"])
        elif "dateReserved" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["dateReserved"])
        else:
            updated = now
        ids[vuln_id] = updated.timestamp()

        if "datePublished" not in vuln["cveMetadata"]:
            vuln["cveMetadata"]["datePublished"] = now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        vuln["cveMetadata"]["dateUpdated"] = now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")

        # Add information about the updater in the cveMetadata field
        if (
            "vulnerabilitylookup_history" not in vuln["cveMetadata"]
            or not vuln["cveMetadata"]["vulnerabilitylookup_history"]
        ):
            vuln["cveMetadata"]["vulnerabilitylookup_history"] = [
                (current_user.email, now.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))
            ]
        else:
            vuln["cveMetadata"]["vulnerabilitylookup_history"].append(
                (current_user.email, now.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))
            )

        new_last_update = now

        # Store the vulnerability in kvrocks
        p = storage.pipeline()
        p.set(vuln_id, orjson.dumps(vuln))

        p.zadd(f"index:{source}", ids)  # type: ignore
        p.zadd("index", ids)  # type: ignore

        if cve_id:
            p.sadd(f"{vuln_id}:link", cve_id)
            p.sadd(f"{cve_id}:link", vuln_id)

        p.hset("last_updates", mapping={source: new_last_update.isoformat()})

        p.execute()

        return vuln, 200


@vulnerability_ns.route("/vulnerability/last")
@vulnerability_ns.route("/vulnerability/last/<int:number>")
@vulnerability_ns.route("/vulnerability/last/<string:source>")
@vulnerability_ns.route("/vulnerability/last/<string:source>/<int:number>")
@vulnerability_ns.doc(description="Get the last vulnerabilities")
@vulnerability_ns.route(
    "/last",
    doc={
        "description": "Alias for /api/vulnerability/last",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.route(
    "/last/<int:number>",
    doc={
        "description": "Alias for /api/vulnerability/last/<int:number>",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.route(
    "/last/<string:source>",
    doc={
        "description": "Alias for /api/vulnerability/last/<string:source>",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.route(
    "/last/<string:source>/<int:number>",
    doc={
        "description": "Alias for /api/vulnerability/last/<string:source>/<int:number>",
        "deprecated": True,
        "doc": False,
    },
)
class Last(Resource):  # type: ignore[misc]
    def get(
        self, source: str | None = None, number: int | None = 30
    ) -> list[dict[str, Any]]:
        return [entry for v_id, entry in vulnerabilitylookup.get_last(source, number)]


@vulnerability_ns.route("/vulnerability/browse")
@vulnerability_ns.route(
    "/browse",
    doc={
        "description": "Alias for /api/vulnerability/browse",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.doc(description="Get the known vendors")
class Vendors(Resource):  # type: ignore[misc]
    def get(self) -> list[str]:
        vendor = request.args.get("vendor", "").lower()
        vendors = list(vulnerabilitylookup.get_vendors())
        if vendor and len(vendor) >= 3:
            vendors = [elem for elem in vendors if vendor in elem]
        return vendors


@vulnerability_ns.route("/vulnerability/browse/<string:vendor>")
@vulnerability_ns.route(
    "/browse/<string:vendor>",
    doc={
        "description": "Alias for /api/vulnerability/browse/<string:vendor>",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.doc(description="Get the known products for a vendor")
class VendorProducts(Resource):  # type: ignore[misc]
    def get(self, vendor: str) -> list[str]:
        return list(vulnerabilitylookup.get_vendor_products(vendor))


@vulnerability_ns.route("/vulnerability/search/<string:vendor>/<string:product>")
@vulnerability_ns.route(
    "/search/<string:vendor>/<string:product>",
    doc={
        "description": "Alias for /api/vulnerability/search/<string:vendor>/<string:product>",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.doc(
    description="Get the the vulnerabilities per vendor and a specific product"
)
class VendorProductVulnerabilities(Resource):  # type: ignore[misc]
    def get(
        self, vendor: str, product: str
    ) -> dict[str, list[tuple[str, dict[str, Any]]]]:
        return vulnerabilitylookup.get_vendor_product_vulnerabilities(vendor, product)
