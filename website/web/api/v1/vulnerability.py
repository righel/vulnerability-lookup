from typing import Any
from typing import Dict
from typing import Tuple
from datetime import datetime, timezone

import logging
import orjson
import re
from flask_login import current_user  # type: ignore[import-untyped]
from flask import request
from flask_restx import abort  # type: ignore[import-untyped]
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource
from redis import Redis
from sqlalchemy import String, cast, func

from vulnerabilitylookup import __version__
from vulnerabilitylookup.default import get_config
from vulnerabilitylookup.helpers import fromisoformat_wrapper
from website.validators import validate_json
from website.web.api.v1.common import auth_func
from website.web.bootstrap import vulnerabilitylookup
from website.models import Comment, Bundle, Sighting
from website.web.permissions import reporter_permission, admin_permission

logger = logging.getLogger(__name__)

local_instance_name = get_config("generic", "local_instance_name").lower()
local_instance_vulnid_pattern = get_config("generic", "local_instance_vulnid_pattern")

vulnerability_ns = Namespace(
    "vulnerability", description="Vulnerability related operations."
)
legacy_ns = Namespace("legacy", description="Legacy endpoints for vulnerabilities.")

storage = Redis(
    host=get_config("generic", "storage_db_hostname"),
    port=get_config("generic", "storage_db_port"),
)

# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument(
    "with_meta",
    type=bool,
    default=False,
    help="Include metada.",
)
parser.add_argument(
    "with_linked",
    type=bool,
    default=False,
    help="Include the linked vulnerabilities.",
)
parser.add_argument(
    "with_comments",
    type=bool,
    default=False,
    help="Include the comments.",
)
parser.add_argument(
    "with_bundles",
    type=bool,
    default=False,
    help="Include the bundles.",
)
parser.add_argument(
    "with_sightings",
    type=bool,
    default=False,
    help="Include the sightings.",
)


vulnerability_query_parser = reqparse.RequestParser()
vulnerability_query_parser.add_argument(
    "data",
    type=dict,
    location="json",
    help="The JSON data (CVE version 5 format) of the security advisory.",
)


@legacy_ns.route(
    "cve/<string:vulnerability_id>", doc=False
)  # "Alias for /api/vulnerability/<string:vulnerability_id
@vulnerability_ns.route("/<string:vulnerability_id>")
class Vulnerability(Resource):  # type: ignore[misc]
    @vulnerability_ns.doc(description="Get a vulnerability.")  # type: ignore[misc]
    @vulnerability_ns.expect(parser)  # type: ignore[misc]
    def get(self, vulnerability_id: str) -> dict[str, Any] | None:
        """Get a vulnerability with its id."""
        with_meta = True if request.args.get("with_meta", "false") == "true" else False
        with_linked = (
            True if request.args.get("with_linked", "false") == "true" else False
        )
        with_comments = (
            True if request.args.get("with_comments", "false") == "true" else False
        )
        with_bundles = (
            True if request.args.get("with_bundles", "false") == "true" else False
        )
        with_sightings = (
            True if request.args.get("with_sightings", "false") == "true" else False
        )

        to_return = vulnerabilitylookup.get_vulnerability(
            vulnerability_id, with_meta=with_meta
        )

        if with_linked:
            to_return["linked"] = vulnerabilitylookup.get_linked_vulnerabilities(vulnerability_id)  # type: ignore[index]
        if with_comments:
            to_return["comments"] = [elem.to_dict() for elem in Comment.query.filter(Comment.vulnerability.ilike(vulnerability_id)).all()]  # type: ignore[index]
        if with_bundles:
            to_return["bundles"] = [  # type: ignore[index]
                elem.to_dict()
                for elem in Bundle.query.filter(
                    func.lower(cast(Bundle.related_vulnerabilities, String)).contains(
                        vulnerability_id.lower()
                    )
                ).all()
            ]
        if with_sightings:
            to_return["sightings"] = [elem.to_dict() for elem in Sighting.query.filter(Sighting.vulnerability.ilike(vulnerability_id)).all()]  # type: ignore[index]

        return to_return

    @vulnerability_ns.doc(description="Delete a vulnerability from the local source.")  # type: ignore[misc]
    @vulnerability_ns.doc(
        responses={
            204: "Success.",
            403: "Admin permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def delete(self, vulnerability_id: str) -> Tuple[dict[Any, Any], int]:
        """Endpoint for deleting a vulnerability.
        We only accept to delete vulnerabilities from the local source."""
        source = (
            vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
            or local_instance_name
        )
        if source != local_instance_name:
            return abort(
                422,
                "You can only delete a vulnerability fron the source {}.".format(
                    local_instance_name
                ),
            )
        storage.delete(vulnerability_id)
        return {}, 204


@vulnerability_ns.route("/")
class VulnerabilitiesList(Resource):  # type: ignore[misc]
    @vulnerability_ns.doc(description="Create a vulnerability with the CVE version 5 format.")  # type: ignore[misc]
    @vulnerability_ns.doc(
        responses={
            200: "Success.",
            400: "JSON validation failed.",
            403: "Reporter permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @vulnerability_ns.expect(vulnerability_query_parser)  # type: ignore[misc]
    @reporter_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[Dict[Any, Any], int]:
        """Endpoint for creating and editing vulnerabilities in the local source."""
        ids: dict[str, float] = {}

        # Validate the JSON payload
        vuln = vulnerability_ns.payload
        if (
            not current_user.is_admin
        ):  # admins can submit non valid JSON for security advisories
            try:
                validate_json(vuln, "circl_vuln")
            except Exception:
                logger.warning("JSON validation failed.")
                abort(400, "JSON validation failed.")

        vuln_id = vuln["cveMetadata"].get("vulnId", "").lower()
        cve_id = vuln["cveMetadata"].get("cveId", "").lower() or None

        if not vuln_id:
            abort(
                400,
                "You must specify a vulnerability id to the format: {}.".format(
                    local_instance_vulnid_pattern
                ),
            )

        source = (
            vulnerabilitylookup.get_vulnerability_source(vuln_id) or local_instance_name
        )
        if source != local_instance_name:
            logger.warning(
                f"Not possible to edit a vulnerability from the source {source}."
            )
            abort(
                422,
                "You can not edit a vulnerability fron the source {}. You must change the vulnerability ID.".format(
                    source
                ),
            )

        now = datetime.now(timezone.utc)

        if "dateUpdated" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["dateUpdated"])
        elif "datePublished" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["datePublished"])
        elif "dateReserved" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["dateReserved"])
        else:
            updated = now
        ids[vuln_id] = updated.timestamp()

        if "datePublished" not in vuln["cveMetadata"]:
            vuln["cveMetadata"]["datePublished"] = now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        vuln["cveMetadata"]["dateUpdated"] = now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")

        # Add information about the updater in the cveMetadata field
        if (
            "vulnerabilitylookup_history" not in vuln["cveMetadata"]
            or not vuln["cveMetadata"]["vulnerabilitylookup_history"]
        ):
            vuln["cveMetadata"]["vulnerabilitylookup_history"] = [
                (current_user.email, now.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))
            ]
        else:
            vuln["cveMetadata"]["vulnerabilitylookup_history"].append(
                (current_user.email, now.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))
            )

        new_last_update = now

        # Store the vulnerability in kvrocks
        p = storage.pipeline()
        p.set(vuln_id, orjson.dumps(vuln))

        p.zadd(f"index:{source}", ids)  # type: ignore
        p.zadd("index", ids)  # type: ignore

        if cve_id:
            p.sadd(f"{vuln_id}:link", cve_id)
            p.sadd(f"{cve_id}:link", vuln_id)

        p.hset("last_updates", mapping={source: new_last_update.isoformat()})

        p.execute()

        return vuln, 200


@vulnerability_ns.route("/last")
@vulnerability_ns.route("/last/<int:number>")
@vulnerability_ns.route("/last/<string:source>")
@vulnerability_ns.route("/last/<string:source>/<int:number>")
@vulnerability_ns.doc(description="Get the last vulnerabilities")
@legacy_ns.route("last", doc=False)  # Alias for /api/vulnerability/last
@legacy_ns.route(
    "last/<int:number>", doc=False
)  # Alias for /api/vulnerability/last/<int:number>
@vulnerability_ns.route(
    "/last",
    doc={
        "description": "Alias for /api/vulnerability/last",
        "deprecated": True,
        "doc": False,
    },
)
@vulnerability_ns.route(
    "/last/<int:number>",
    doc={
        "description": "Alias for /api/vulnerability/last/<int:number>",
        "deprecated": True,
        "doc": False,
    },
)
class Last(Resource):  # type: ignore[misc]
    def get(
        self, source: str | None = None, number: int | None = 30
    ) -> list[dict[str, Any]]:
        return [entry for v_id, entry in vulnerabilitylookup.get_last(source, number)]


@vulnerability_ns.route("/search/<string:vendor>/<string:product>")
@vulnerability_ns.doc(
    description="Returns a list of vulnerabilities related to the product."
)
@legacy_ns.route(
    "search/<string:vendor>/<string:product>", doc=False
)  # Alias for /api/vulnerability/search/<string:vendor>/<string:product>
class VendorProductVulnerabilities(Resource):  # type: ignore[misc]
    def get(
        self, vendor: str, product: str
    ) -> dict[str, list[tuple[str, dict[str, Any]]]]:
        """Returns a list of vulnerabilities related to the product."""
        return vulnerabilitylookup.get_vendor_product_vulnerabilities(vendor, product)


@vulnerability_ns.route("/browse/")
@vulnerability_ns.doc(description="Get the known vendors.")
class Vendors(Resource):  # type: ignore[misc]
    def get(self) -> list[str]:
        """Get the known vendors."""
        vendor = request.args.get("vendor", "").lower()
        vendors = list(vulnerabilitylookup.get_vendors())
        if vendor and len(vendor) >= 3:
            vendors = [elem for elem in vendors if vendor in elem]
        return vendors


@vulnerability_ns.route("/cpesearch/<string:cpe>")
@vulnerability_ns.doc(description="Get vulnerabilities by CPE.")
@vulnerability_ns.doc(
    responses={
        200: "Success.",
        404: "No match found.",
    }
)
class CPESearch(Resource):  # type: ignore[misc]
    def get(self, cpe: str) -> dict[str, list[tuple[str, dict[str, Any]]]]:
        """Get vulnerabilities by CPE."""
        # Pattern to match the vendor and product parts of the CPE string
        pattern = r"^cpe:\d+\.\d+:[aho]:(.*?):(.*?)(:|$)"
        match = re.match(pattern, cpe)
        if match:
            vendor = match.group(1)
            product = match.group(2)
            return vulnerabilitylookup.get_vendor_product_vulnerabilities(
                vendor, product
            )
        else:
            return abort(404, "No match found.")
