// Function to prepare data for Chart.js
function prepareChartData(sightings) {
  const dataPerDay = {};

  // Aggregate data per day and by type
  sightings.forEach(sighting => {
      const date = new Date(sighting.creation_timestamp).toISOString().split('T')[0]; // Extract date (YYYY-MM-DD)
      const type = sighting.type;

      if (!dataPerDay[date]) {
          dataPerDay[date] = {
              "seen": 0,
              "confirmed": 0,
              "exploited": 0,
              "patched": 0,
              "not-confirmed": 0,
              "not-exploited": 0,
              "not-patched": 0
          };
      }

      if (dataPerDay[date][type] !== undefined) {
          dataPerDay[date][type] += 1; // Increment the count of the specific sighting type for that day
      }
  });

  return dataPerDay;
}

let sightingsChart; // Global variable to hold the chart instance

// Define the color map using shades of green for positive and red for negative values
const colorMap = {
  'exploited': 'hsl(0, 70%, 35%)',        // Darker Red
  'confirmed': 'hsl(0, 70%, 50%)',        // Medium Red
  'seen': 'hsl(0, 70%, 65%)',             // Lighter Red
  'patched': 'hsl(120, 50%, 50%)',        // Green
  'not-confirmed': 'hsl(0, 0%, 35%)',     // Darker Grey
  'not-exploited': 'hsl(0, 0%, 50%)',     // Medium Grey
  'not-patched': 'hsl(0, 0%, 65%)'        // Lighter Grey
};

// Function to draw the Chart using Chart.js
function drawBarChart(sightings) {
  const dataPerDay = prepareChartData(sightings);
  let labels = Object.keys(dataPerDay); // Dates (X-axis)

  // Sort the labels (dates) in chronological order (oldest to newest)
  labels = labels.sort((a, b) => new Date(a) - new Date(b));

  const types = ["seen", "confirmed", "exploited", "patched", "not-confirmed", "not-exploited", "not-patched"];

  // Data for each type
  const datasets = types.map((type, index) => {
      const isBelowAxis = type.startsWith('not-');

      return {
          label: type,
          backgroundColor: colorMap[type], // Use the color map with shades
          // Use negative values for 'not-*' types to place them below the X-axis
          data: labels.map(date => isBelowAxis ? -dataPerDay[date][type] : dataPerDay[date][type]),
          barThickness: 20 // Control bar width
      };
  });

  const ctx = document.getElementById('sightingsChart').getContext('2d');

  // If the chart already exists, destroy it before creating a new one
  if (sightingsChart) {
    sightingsChart.destroy();
  }

  // Create a new chart instance
  sightingsChart = new Chart(ctx, {
      type: 'bar',
      data: {
          labels: labels, // X-axis: Sorted Dates
          datasets: datasets // Y-axis: Data per type
      },
      options: {
          maintainAspectRatio: false, // Allow the chart to grow in width
          scales: {
              x: {
                  stacked: false, // Disable stacking on the X-axis
                  beginAtZero: true,
                  min: 0, // Set minimum range on x-axis to include all data
                  max: labels.length - 1 // Limit the max to the total number of labels
              },
              y: {
                  stacked: false, // Disable stacking on the Y-axis
                  beginAtZero: true, // Center 0 on Y-axis
                  ticks: {
                      stepSize: 1, // Set step size to 1 to ensure integers only
                      callback: function(value) {
                          return Math.round(Math.abs(value)); // Display all y-axis values as positive numbers
                      }
                  }
              }
          },
          plugins: {
              legend: {
                  display: true,
                  position: 'top',
                  title: {
                    text: 'Type of sightings',
                    display: true
                  }
              },
              tooltip: {
                  callbacks: {
                      // Show positive numbers in tooltips even for 'not-*' bars below the X-axis
                      label: function(tooltipItem) {
                          return `${tooltipItem.dataset.label}: ${Math.abs(tooltipItem.raw)}`;
                      }
                  }
              }
          }
      }
  });
}



function drawBarChartHomePage(sightings, chartDivId, title, backgroundColor) {
  const vulnerabilityCounts = new Map();

  // Count occurrences with a regular `for` loop
  for (let i = 0; i < sightings.length; i++) {
      const vuln = sightings[i].vulnerability.toLowerCase();
      vulnerabilityCounts.set(vuln, (vulnerabilityCounts.get(vuln) || 0) + 1);
  }

  // Create an array from vulnerabilityCounts and use a custom function to keep only the top 8
  const sortedVulns = Array.from(vulnerabilityCounts.entries())
      .reduce((topEight, current) => {
          topEight.push(current);
          topEight.sort(([, a], [, b]) => b - a);
          if (topEight.length > 8) topEight.pop(); // Keep the size to 8
          return topEight;
      }, []);

  const labels = sortedVulns.map(([vuln]) => vuln);
  const dataCounts = sortedVulns.map(([, count]) => count);

  const ctx = document.getElementById(chartDivId).getContext('2d');
  const myChart = new Chart(ctx, {
      type: 'bar',
      data: {
          labels,
          datasets: [{
              label: title,
              data: dataCounts,
              backgroundColor,
              borderColor: 'white',
              borderWidth: 1
          }]
      },
      options: {
        scales: {
            x: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Vulnerabilities'
                }
            },
            y: {
                title: {
                    display: true,
                    text: 'Sightings'
                },
                ticks: {
                  stepSize: 1
              }
            }
        },
        onClick: (event) => {
          const activePoints = myChart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
          if (activePoints.length > 0) {
              const index = activePoints[0].index;
              const vulnId = labels[index];
              window.location.href = `/vuln/${vulnId}`;
          }
        }
      }
  });
}
