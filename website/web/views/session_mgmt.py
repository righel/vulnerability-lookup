#!/usr/bin/env python3

import logging
import sqlalchemy
from datetime import datetime, timezone, timedelta
from flask import abort
from flask import current_app
from flask import flash
from flask import render_template
from flask import redirect
from flask import request
from flask import session
from flask import url_for
from flask_login import current_user  # type: ignore[import-untyped]
from flask_login import LoginManager
from flask_login import login_required
from flask_login import logout_user
from flask_principal import AnonymousIdentity  # type: ignore[import-untyped]
from flask_principal import identity_changed
from flask_principal import identity_loaded
from flask_principal import Principal
from flask_principal import session_identity_loader
from flask_principal import UserNeed
from werkzeug import Response as WerkzeugResponse

from website.lib.user_utils import get_b64encoded_qr_image
from website.lib.utils import query_country_code_mmdb
from website.models import User
from website.notifications import notifications
from website.web.bootstrap import application
from website.web.bootstrap import db
from website.web.forms import LoginForm
from website.web.forms import SignupForm
from website.web.forms import TwoFactorForm
from website.web.helpers import src_request_ip
from website.web.permissions import admin_role
from website.web.permissions import commenter_role
from website.web.permissions import login_user_bundle
from website.web.permissions import reporter_role
from website.web.views.user import user_bp

logger = logging.getLogger(__name__)

Principal(current_app)
# Create a permission with a single Need, in this case a RoleNeed.

login_manager = LoginManager()
login_manager.init_app(current_app)
login_manager.login_view = "user_bp.login"
login_manager.login_message = "Please log in to access this page."
login_manager.login_message_category = "info"


@identity_loaded.connect_via(current_app._get_current_object())  # type: ignore
def on_identity_loaded(sender, identity) -> None:
    # Set the identity user object
    identity.user = current_user

    # Add the UserNeed to the identity
    if current_user.is_authenticated:
        identity.provides.add(UserNeed(current_user.id))
        if current_user.is_admin:
            identity.provides.add(admin_role)
        if current_user.is_commenter:
            identity.provides.add(commenter_role)
        if current_user.is_reporter:
            identity.provides.add(reporter_role)
            identity.provides.add(commenter_role)


@login_manager.user_loader  # type: ignore[misc]
def load_user(user_id: int) -> bool:
    return User.query.filter(
        User.id == user_id, User.is_active == True, User.is_confirmed == True
    ).first()  # noqa


@current_app.before_request
def before_request() -> None:
    if current_user.is_authenticated:
        # Only update if the last_seen was updated more than 1 minute ago
        now = datetime.now(timezone.utc)
        if not current_user.last_seen or now - current_user.last_seen.replace(
            tzinfo=timezone.utc
        ) > timedelta(minutes=1):
            current_user.last_seen = now
            db.session.commit()


@user_bp.route("/login", methods=["GET", "POST"])
def login() -> str | WerkzeugResponse:
    """Login page for unauthenticated users.
    In case of successful authentication the user is redirected to the
    Two-Factor Authentication page."""
    if current_user.is_authenticated:
        if (
            not application.config["ENFORCE_2FA"]
            or current_user.is_two_factor_authentication_enabled
        ):
            flash("You are already logged in.", "info")
            return redirect(url_for("home_bp.search"))
        else:
            flash(
                "You have not enabled 2-Factor Authentication. Please enable it.",
                "info",
            )
            return redirect(url_for("user_bp.setup_two_factor_auth"))

    form = LoginForm()
    if request.method == "POST" and form.validate():
        session["username"] = form.login.data
        user = User.query.filter(
            User.login == session["username"],
            User.is_active == True,
            User.is_confirmed == True,
        ).first()
        if (
            application.config["ENFORCE_2FA"]
            and not user.is_two_factor_authentication_enabled
        ):
            # 2FA enforced and is not enabled for this user: redirect to 2FA setup
            flash(
                "You have not enabled 2-Factor Authentication. Please enable first to login.",
                "info",
            )
            return redirect(url_for("user_bp.setup_two_factor_auth"))
        elif application.config["ENFORCE_2FA"]:
            # 2FA enforced and is enabled for this user: redirect to 2FA verification
            return redirect(url_for("user_bp.verify_two_factor_auth"))
        elif (
            not application.config["ENFORCE_2FA"]
            and user.is_two_factor_authentication_enabled
        ):
            # 2FA is not enforced but enabled for this user: redirect to 2FA verification
            return redirect(url_for("user_bp.verify_two_factor_auth"))
        else:
            # 2FA is not enforced and not enabled for this user: login the user
            session.pop("username", None)
            login_user_bundle(user)
            return redirect(url_for("home_bp.search"))

    return render_template("user/login.html", form=form)


@user_bp.route("/logout")
@login_required  # type: ignore[misc]
def logout() -> WerkzeugResponse:
    """Logout the authenticated user.
    Remove the session keys."""
    # Remove the user information from the session
    logout_user()

    session.pop("username", None)

    # Remove session keys set by Flask-Principal
    for key in ("identity.name", "identity.auth_type"):
        session.pop(key, None)

    # Tell Flask-Principal the user is anonymous
    identity_changed.send(current_app, identity=AnonymousIdentity())
    session_identity_loader()

    return redirect(url_for("user_bp.login"))


@user_bp.route("/signup", methods=["GET", "POST"])
def signup() -> str | WerkzeugResponse:
    """Returns a page dedicated to the signup for the new users."""
    if not application.config["SELF_REGISTRATION"]:
        flash("Self-registration is disabled.", "warning")
        return redirect(url_for("home_bp.search"))
    if current_user.is_authenticated:
        return redirect(url_for("home_bp.search"))

    form = SignupForm()
    if request.method == "POST" and form.validate():
        try:
            remote_addr = src_request_ip(request) or ""
            country_alpha_3_code = query_country_code_mmdb(remote_addr)
        except Exception as e:
            country_alpha_3_code = ""

        try:
            new_user = User(
                login=form.login.data,
                name=form.name.data,
                organisation=form.organisation.data,
                country_code=country_alpha_3_code,
                email=form.email.data,
                pwdhash="",
                is_active=True,
                is_confirmed=False,
                is_admin=False,
                is_commenter=True,
                last_seen=None,
            )
            db.session.add(new_user)
            db.session.commit()
        except AssertionError as e:
            db.session.rollback()
            flash(f"{e}", "danger")
            return render_template("user/signup.html", form=form)
        except sqlalchemy.exc.IntegrityError:
            db.session.rollback()
            flash("Problem while creating the account.", "danger")
            return render_template("user/signup.html", form=form)

        # Send the confirmation email
        try:
            notifications.confirm_account(new_user)
        except Exception as error:
            flash(
                f"Problem while sending activation email: {error}",
                "danger",
            )

        flash(
            "Your account has been created. Check your mail to confirm it.",
            "success",
        )

        return redirect(url_for("home_bp.search"))

    return render_template("user/signup.html", form=form)


@user_bp.route("/setup-2fa", methods=["GET"])
def setup_two_factor_auth() -> tuple[str, int, dict[str, str]]:
    """Setup Two-Factor authentication for the username in session.
    A QRCode is generated and returned in the HTML page."""
    assert None is not session.get("username", None), abort(403)
    form = TwoFactorForm(request.form)
    user = User.query.filter(
        User.login == session["username"],
        User.is_confirmed == True,
    ).first()
    if user is None:
        session.pop("username", None)
        abort(403)
    secret = user.secret_token
    uri = user.get_authentication_setup_uri()
    base64_qr_image = get_b64encoded_qr_image(uri)
    # make sure the browser does not cache the QRCode
    return (
        render_template(
            "user/setup-2fa.html", secret=secret, qr_image=base64_qr_image, form=form
        ),
        200,
        {
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Pragma": "no-cache",
            "Expires": "0",
        },
    )


@user_bp.route("/verify-2fa", methods=["GET", "POST"])
def verify_two_factor_auth() -> str | WerkzeugResponse:
    """Verify the token generated by the authentication software of the user."""
    assert None is not session.get("username", None), abort(403)
    user = User.query.filter(
        User.login == session["username"],
        User.is_confirmed == True,
    ).first()
    if user is None:
        session.pop("username", None)
        abort(403)
    form = TwoFactorForm(request.form)
    if form.validate_on_submit():
        if user.is_otp_valid(form.otp.data):
            if user.is_two_factor_authentication_enabled:
                # Verification
                flash("2FA verification successful. You are logged in!", "success")
                session.pop("username", None)
                login_user_bundle(user)
                return redirect(url_for("home_bp.search"))
            else:
                # Setup of Two-Factor Authentication
                try:
                    user.is_two_factor_authentication_enabled = True
                    db.session.commit()
                    session.pop("username", None)
                    flash("2FA setup successful. You are logged in!", "success")
                    login_user_bundle(user)
                    return redirect(url_for("user_bp.form"))
                except Exception:
                    db.session.rollback()
                    flash("2FA setup failed. Please try again.", "danger")
                    return redirect(url_for("user_bp.setup_two_factor_auth"))
        else:
            flash("Invalid OTP. Please try again.", "danger")
            return render_template("user/verify-2fa.html", form=form)
    else:
        if not user.is_two_factor_authentication_enabled:
            flash(
                "You have not enabled 2-Factor Authentication. Please enable it first.",
                "info",
            )
        return render_template("user/verify-2fa.html", form=form)
