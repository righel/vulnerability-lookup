#!/usr/bin/env python3

from datetime import timezone

import markdown  # type: ignore[import-untyped]
import pycountry
from flask import abort
from flask import Blueprint
from flask import flash
from flask import make_response
from flask import session
from flask import Response
from flask import redirect
from flask import render_template
from flask import request
from flask import url_for
from flask_login import current_user  # type: ignore[import-untyped]
from flask_login import login_required
from flask_login import logout_user
from flask_paginate import get_page_args  # type: ignore[import-untyped]
from flask_paginate import get_parameter
from flask_paginate import Pagination
from feedgen.feed import FeedGenerator  # type: ignore[import-untyped]
from werkzeug import Response as WerkzeugResponse
from werkzeug.security import generate_password_hash

from vulnerabilitylookup.default import get_config
from website.notifications import notifications
from website.web.bootstrap import application
from website.web.bootstrap import db
from website.web.bootstrap import vulnerabilitylookup
from website.lib.user_utils import confirm_token
from website.lib.utils import top_contributors
from website.models import Bundle
from website.models import Comment
from website.models import Sighting
from website.models import User
from website.web.forms import ProfileForm
from website.web.forms import AccountConfirmationForm
from website.web.forms import AccountRecoveryForm
from website.web.permissions import reporter_permission

user_bp = Blueprint("user_bp", __name__, url_prefix="/user", template_folder="user")
users_bp = Blueprint("users_bp", __name__, url_prefix="/users", template_folder="user")


@users_bp.route("/", methods=["GET"])
def list_users() -> str:
    """Returns a page with a list of users (directory)."""
    users_sorted_by_contributions = [
        (elem[1], elem[2]) for elem in top_contributors(-1) if elem[2] > 0
    ]
    # Users who have never contributed are sorted by last_seen
    contributors_login = [user[0] for user in users_sorted_by_contributions]
    non_contributors = (
        User.query.filter(User.is_active == True, User.is_confirmed == True)
        .order_by(User.last_seen.desc())
        .filter(~User.login.in_(contributors_login))
    )

    users = []
    for user in contributors_login:
        users.append(User.query.filter(User.login == user).first())
    users.extend(non_contributors.all())

    page, per_page, offset = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    page_name = get_parameter()
    per_page_name = get_parameter(default="per_page")
    pagination = Pagination(
        total=len(users),
        record_name="users",
        css_framework="bootstrap5",
        **{page_name: page, per_page_name: per_page},
    )
    users = users[offset : offset + per_page]
    return render_template("user/users.html", users=users, pagination=pagination)


@user_bp.route("/<string:login>", methods=["GET"])
def profile(login: str = "") -> str:
    """Returns a page with some information about the user given in parameter."""
    user = User.query.filter(User.login == login).first()
    if user is None:
        abort(404)

    if user.bio:
        user.bio = markdown.markdown(user.bio)

    try:
        user_country = pycountry.countries.get(alpha_3=user.country_code).name
    except Exception:
        user_country = ""

    top_5_contributors = top_contributors(limit=5)

    return render_template(
        "user/user.html",
        user=user,
        user_country=user_country,
        nb_contributions=user.nb_contributions(),
        top_contributor=True if user.id is top_5_contributors[0][0] else False,
        top_3_contributors=True
        if user.id in [elem[0] for elem in top_5_contributors[:3]]
        else False,
        top_5_contributors=True
        if user.id in [elem[0] for elem in top_5_contributors]
        else False,
    )


@user_bp.route("/profile", methods=["GET"])
@login_required  # type: ignore[misc]
def form() -> str:
    """Returns the form to edit the current user."""
    user = User.query.filter(User.id == current_user.id).first()
    form = ProfileForm(obj=user)
    form.populate_obj(current_user)
    action = "Edit user"
    head_titles = [action]
    head_titles.append(user.login)
    return render_template(
        "user/edit_user.html",
        action=action,
        head_titles=head_titles,
        form=form,
        user=user,
    )


@user_bp.route("/profile", methods=["POST"])
@login_required  # type: ignore[misc]
def process_form() -> str | WerkzeugResponse:
    """Process the form for the user edition."""
    form = ProfileForm()
    user = User.query.filter(User.id == current_user.id).first()

    if not form.validate():
        return render_template("user/edit_user.html", form=form, user=user)

    try:
        form.populate_obj(user)
    except AssertionError as e:
        flash(f"{e}", "danger")
        return render_template("user/edit_user.html", form=form, user=user)

    if form.password.data:
        user.pwdhash = generate_password_hash(form.password.data)
    db.session.commit()
    flash(
        f"User {form.login.data} successfully updated.",
        "success",
    )
    return redirect(url_for("user_bp.form"))


@user_bp.route("/generate_apikey", methods=["GET"])
@login_required  # type: ignore[misc]
def generate_apikey() -> WerkzeugResponse:
    """Generate an API key for a user."""
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    user.generate_apikey()
    db.session.commit()
    flash("New API key generated.", "success")
    return redirect(url_for("user_bp.form"))


@user_bp.route("/toggle_2fa", methods=["GET"])
@login_required  # type: ignore[misc]
def toggle_2FA() -> WerkzeugResponse:
    """Toggle 2FA."""
    if application.config["ENFORCE_2FA"]:
        flash("Impossible to disable Two-Factor Authentication.", "success")
        return redirect(url_for("user_bp.form"))
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    user.is_two_factor_authentication_enabled = (
        not user.is_two_factor_authentication_enabled
    )
    db.session.commit()
    if user.is_two_factor_authentication_enabled:
        session["username"] = user.login
        flash(
            "Configure Two-Factor Authentication.",
            "info",
        )
        return redirect(url_for("user_bp.setup_two_factor_auth"))
    else:
        flash("Two-Factor Authentication disabled.", "success")
        return redirect(url_for("user_bp.form"))


@user_bp.route("/delete_account", methods=["GET"])
@login_required  # type: ignore[misc]
def delete_account() -> WerkzeugResponse:
    """Delete the account of the authenticated user.
    In fact, it sets the value of is_active to False and delete the session."""
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    user.is_active = False
    db.session.commit()
    logout_user()
    flash("Account deleted.", "success")
    return redirect(url_for("index"))


@user_bp.route("/confirm_account/<string:token>", methods=["GET", "POST"])
def confirm_account(token: str = "") -> str | WerkzeugResponse:
    """
    Confirm the account of a user with the token that the user has received
    previously by email.
    """
    # Check the token
    user, login = None, None
    if token != "":
        login = confirm_token(token)
    if login:
        user = User.query.filter(User.login == login).first()
    if user is None:
        flash("Impossible to activate this account.", "danger")
        return redirect(url_for("user_bp.login"))

    # Management of the Web form
    form = AccountConfirmationForm()

    if request.method == "GET":
        # Asks the user to provide a new password, in the case the token is
        # valid
        if user is not None:
            return render_template("user/account_recovery_set_password.html", form=form)
        else:
            flash("Impossible to activate this account.", "danger")
    else:
        # Update the password of the user (if the token is valid and if the
        # two passwards are equal)
        if form.password1.data == form.password2.data:
            user.pwdhash = generate_password_hash(form.password1.data)
            user.is_confirmed = True
            db.session.add(user)
            db.session.commit()
            flash("Your password has been updated.", "success")
        else:
            flash("Password must be the same.", "danger")
            return render_template("user/account_recovery_set_password.html", form=form)

        if (
            application.config["ENFORCE_2FA"]
            and not user.is_two_factor_authentication_enabled
        ):
            session["username"] = user.login
            return redirect(url_for("user_bp.setup_two_factor_auth"))

    return redirect(url_for("user_bp.login"))


@user_bp.route("/account_recovery", methods=["GET", "POST"])
def account_recovery() -> str | WerkzeugResponse:
    """Returns a form for the account recovery.
    The user will have to provide the login of the account to recover. It can
    not be done via email address since an email address is not unique.
    """
    form = AccountRecoveryForm()
    if request.method == "GET":
        return render_template("user/account_recovery.html", form=form)
    else:
        user = User.query.filter(User.login == form.login.data).first()
        if user is None:
            flash(
                "This user does not exist.",
                "danger",
            )
            return redirect(url_for("home_bp.search"))

        # Send the recovery email with the temporary token
        try:
            notifications.account_recovery(user)
        except Exception as error:
            flash(
                f"Problem while sending activation email: {error}",
                "danger",
            )
            return redirect(url_for("home_bp.search"))

        flash("An email with a recovery link has been sent to you.", "success")

    return redirect(url_for("home_bp.search"))


@user_bp.route("/submit", methods=["GET"])
@user_bp.route("/edit/<string:vulnerability_id>", methods=["GET"])
@login_required  # type: ignore[misc]
@reporter_permission.require(http_exception=403)  # type: ignore[misc]
def vulnogram(vulnerability_id: str = "") -> str | WerkzeugResponse:
    """Returns a form using vulnogram in order to edit or create a new vulnerability (CVE list v5)."""
    vulnerability = vulnerabilitylookup.get_vulnerability(
        vulnerability_id, with_meta=True
    )
    if vulnerability_id and None is vulnerability:
        flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
        return redirect(url_for("home_bp.search"))

    local_instance_name = get_config("generic", "local_instance_name").lower()
    local_instance_vulnid_pattern = get_config(
        "generic", "local_instance_vulnid_pattern"
    )
    local_instance_vulnid_example = get_config(
        "generic", "local_instance_vulnid_example"
    )
    source = vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
    return render_template(
        "vulnogram/index.html",
        vulnerability_id=vulnerability_id,
        source=source,
        local_instance_name=local_instance_name,
        local_instance_vulnid_pattern=local_instance_vulnid_pattern,
        local_instance_vulnid_example=local_instance_vulnid_example,
    )


@user_bp.route("/sightings", methods=["GET"])
@login_required  # type: ignore[misc]
def sightings() -> str:
    sightings = Sighting.query.filter(Sighting.author_id == current_user.id).order_by(
        Sighting.creation_timestamp.desc()
    )

    # Pagination
    page, per_page, offset = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    page_name = get_parameter()
    per_page_name = get_parameter(default="per_page")
    pagination = Pagination(
        total=sightings.count(),
        record_name="sightings",
        css_framework="bootstrap5",
        **{page_name: page, per_page_name: per_page},
    )
    sightings = sightings.offset(offset).limit(per_page)

    return render_template(
        "user/sightings.html", sightings=sightings, pagination=pagination
    )


@user_bp.route("/sightings/<uuid:sighting_uuid>/delete", methods=["GET"])
@login_required  # type: ignore[misc]
def delete_sighting(sighting_uuid: str = "") -> WerkzeugResponse:
    sighting = Sighting.query.filter(Sighting.uuid == sighting_uuid).first()
    if sighting is None:
        abort(404)
    if current_user.is_admin or current_user.id == sighting.author_id:
        db.session.delete(sighting)
        db.session.commit()
        flash("Sighting deleted.", "success")
    else:
        flash("You cannot delete this sighting.", "danger")
    return redirect(url_for("user_bp.sightings"))


@user_bp.route(
    "/<string:login>.<string:format>", defaults={"per_page": 10}, methods=["GET"]
)
def feed_activity(
    login: str = "", per_page: int = 10, format: str = "atom"
) -> Response:
    """RSS/ATOM feed for the recent activity of a user. In this context activity is
    the creation of a comment or a bundle."""
    public_domain = get_config("generic", "public_domain")
    _, per_page, offset = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    feed_max_per_page = application.config.get("FEED_MAX_PER_PAGE", 50)
    if per_page > feed_max_per_page:
        per_page = feed_max_per_page

    fg = FeedGenerator()
    fg.id(f"https://{public_domain}/comment/feed")
    fg.title(f"Most recent activity.")
    fg.author(
        {
            "name": "Vulnerability Lookup",
            "email": application.config.get("ADMIN_EMAIL", ""),
        }
    )
    fg.link(href=f"https://{public_domain}", rel="alternate")
    fg.subtitle(f"Contains the recent activity for {login}.")
    fg.language("en")

    query = Comment.query.filter(Comment.is_published == True)
    query = query.filter(Comment.author.has(login=login))
    query = query.order_by(Comment.timestamp.desc())
    comments = query.offset(offset).limit(per_page)
    for comment in comments:
        fe = fg.add_entry()
        fe.id(f"https://{public_domain}/comment/{comment.uuid}")
        fe.title(comment.title)
        fe.link(href=f"https://{public_domain}/comment/{comment.uuid}")
        fe.content(comment.description)
        fe.description(comment.description)
        fe.published(comment.timestamp.replace(tzinfo=timezone.utc))

    query = Bundle.query
    query = query.filter(Bundle.author.has(login=login))
    query = query.order_by(Bundle.timestamp.desc())
    bundles = query.offset(offset).limit(per_page)
    for bundle in bundles:
        fe = fg.add_entry()
        fe.id(f"https://{public_domain}/bundle/{bundle.uuid}")
        fe.title(bundle.name)
        fe.link(href=f"https://{public_domain}/bundle/{bundle.uuid}")
        fe.content(bundle.description)
        fe.description(bundle.description)
        fe.published(bundle.timestamp.replace(tzinfo=timezone.utc))

    if format == "atom":
        feed = fg.atom_str(pretty=True)
    else:
        feed = make_response(fg.rss_str(pretty=True))
        feed.mimetype = "application/rss+xml"
        feed.headers["Content-Type"] = "application/rss+xml"
    return feed
