#!/usr/bin/env python3

from datetime import timezone

import markdown  # type: ignore[import-untyped]
from markdown.extensions.tables import TableExtension  # type: ignore[import-untyped]
from feedgen.feed import FeedGenerator  # type: ignore[import-untyped]
from flask import (
    abort,
    Blueprint,
    flash,
    request,
    redirect,
    render_template,
    make_response,
    Response,
    url_for,
)
from flask_login import current_user  # type: ignore[import-untyped]
from flask_login import login_required
from flask_paginate import get_page_args  # type: ignore[import-untyped]
from werkzeug import Response as WerkzeugResponse

from website.web.bootstrap import db
from vulnerabilitylookup.default import get_config
from website.models import Comment
from website.web.bootstrap import application

comment_bp = Blueprint(
    "comment_bp", __name__, url_prefix="/comment", template_folder="comments"
)
comments_bp = Blueprint(
    "comments_bp", __name__, url_prefix="/comments", template_folder="comments"
)

local_instance_name = get_config("generic", "local_instance_name").lower()


@comments_bp.route("/", methods=["GET"])
def list_comments() -> str:
    return render_template("comments/comments.html")


@comment_bp.route("/<uuid:comment_uuid>", methods=["GET"])
def get(comment_uuid: str = "") -> str:
    """Return details about the comment."""
    elem = Comment.query.filter(Comment.uuid == comment_uuid).first()
    if elem is None:
        abort(404)
    html_from_markdown = markdown.markdown(
        elem.description,
        extensions=["fenced_code", TableExtension(use_align_attribute=True)],
    )
    return render_template(
        "comments/comment.html", comment=elem, description=html_from_markdown
    )


@comment_bp.route("/create", methods=["GET"])
@comment_bp.route("/edit/<uuid:comment_uuid>", methods=["GET"])
@login_required  # type: ignore[misc]
def form(comment_uuid: str = "") -> str:
    """Returns a page in order to create or edit a comment."""
    action = "Create a comment"
    head_titles = [action]

    if not comment_uuid:
        # Creation of a new comment
        return render_template(
            "comments/edit_comment.html",
            action=action,
            head_titles=head_titles,
            comment={},
        )

    # Edition of an existing comment
    comment = Comment.query.filter(Comment.uuid == comment_uuid).first()
    action = "Edit a comment"
    head_titles = [action]
    head_titles.append(comment.title)
    return render_template(
        "comments/edit_comment.html",
        action=action,
        head_titles=head_titles,
        comment=comment,
    )


@comment_bp.route("/delete/<uuid:comment_uuid>", methods=["GET"])
@login_required  # type: ignore[misc]
def delete_comment(comment_uuid: str) -> WerkzeugResponse:
    """Delete a comment."""
    comment = Comment.query.filter(Comment.uuid == comment_uuid).first()
    if comment is None:
        abort(404)
    if current_user.is_admin or current_user.id == comment.author_id:
        db.session.delete(comment)
        db.session.commit()
        flash("Comment deleted.", "success")
    else:
        flash("You cannot delete this comment.", "danger")
    return redirect(url_for("comments_bp.list_comments"))


@comments_bp.route("/feed.<string:format>", defaults={"per_page": 10}, methods=["GET"])
def feed_comments(per_page: int = 10, format: str = "atom") -> Response:
    """RSS/ATOM feed for the recent comments."""
    vulnerability = request.args.get("vulnerability", "")
    user = request.args.get("user", "")
    public_domain = get_config("generic", "public_domain")
    _, per_page, offset = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    feed_max_per_page = application.config.get("FEED_MAX_PER_PAGE", 50)
    if per_page > feed_max_per_page:
        per_page = feed_max_per_page
    fg = FeedGenerator()
    fg.id(f"https://{public_domain}/comments/feed")
    fg.title(f"Most recent comment.")
    fg.author(
        {
            "name": "Vulnerability Lookup",
            "email": application.config.get("ADMIN_EMAIL", ""),
        }
    )
    fg.link(href=f"https://{public_domain}", rel="alternate")
    fg.subtitle(f"Contains only the most {per_page} recent comments.")
    fg.language("en")

    query = Comment.query.filter(Comment.is_published == True)
    if vulnerability:
        query = query.filter(Comment.vulnerability.ilike("%" + vulnerability + "%"))
    if user:
        query = query.filter(Comment.author.has(login=user))
    query = query.order_by(Comment.timestamp.desc())

    comments = query.offset(offset).limit(per_page)

    for comment in comments:
        fe = fg.add_entry()
        fe.author(
            [
                {
                    "name": comment.author.name,
                    "uri": url_for(
                        "user_bp.profile", login=comment.author.login, _external=True
                    ),
                }
            ]
        )
        fe.id(f"https://{public_domain}/comment/{comment.uuid}")
        fe.title(comment.title)
        fe.link(href=f"https://{public_domain}/comment/{comment.uuid}")
        fe.content(comment.description)
        fe.description(comment.description)
        fe.published(comment.timestamp.replace(tzinfo=timezone.utc))
    if format == "atom":
        feed = fg.atom_str(pretty=True)
    else:
        feed = make_response(fg.rss_str(pretty=True))
        feed.mimetype = "application/rss+xml"
        feed.headers["Content-Type"] = "application/rss+xml"
    return feed
