#!/usr/bin/env python3

from typing import Generator, Callable, Dict, List, Any

from flask import Blueprint, request, jsonify, Response, stream_with_context
import threading

import redis

from vulnerabilitylookup.default import get_config
from website.web.bootstrap import csrf


# Define a type alias for a callback function
Callback = Callable[[str], None]

# Create the blueprint
pubsub_bp = Blueprint("pubsub", __name__, url_prefix="/pubsub")
csrf.exempt(pubsub_bp)

# Initialize Valkey/Redis client
redis_client = redis.Redis(
    host=get_config("generic", "storage_db_hostname"),
    port=get_config("generic", "storage_db_port"),
    decode_responses=True,
)

# Thread-safe dictionary for subscriptions
subscriptions: Dict[str, List[Callback]] = {}


@pubsub_bp.route("/publish", methods=["POST"])
def publish() -> Response | tuple[Response, int]:
    """Publish a message to a topic"""
    data: Any = request.json
    if not data or "topic" not in data or "message" not in data:
        return (
            jsonify({"error": 'Invalid payload. "topic" and "message" are required.'}),
            400,
        )

    topic: str = data["topic"]
    message: str = data["message"]

    # Publish the message to the Valkey topic
    redis_client.publish(topic, message)
    return jsonify({"message": "Message published successfully"}), 200


@pubsub_bp.route("/subscribe/<string:topic>", methods=["GET"])
def subscribe(topic: str) -> Response:
    """Subscribe to a topic and stream messages"""

    def stream() -> Generator[str, None, None]:
        pubsub = redis_client.pubsub()
        pubsub.subscribe(topic)
        try:
            for message in pubsub.listen():
                if message["type"] == "message":
                    yield f"data: {message['data']}\n\n"
        except GeneratorExit:
            pubsub.unsubscribe(topic)

    return Response(stream_with_context(stream()), content_type="text/event-stream")


# Background worker for handling subscriptions
def start_subscriber() -> None:
    pubsub = redis_client.pubsub()
    pubsub.subscribe(*subscriptions.keys())

    for message in pubsub.listen():
        if message["type"] == "message":
            topic: str = message["channel"]
            if topic in subscriptions:
                for callback in subscriptions[topic]:
                    callback(message["data"])


# Start the background subscriber in a separate thread
subscription_thread: threading.Thread = threading.Thread(
    target=start_subscriber, daemon=True
)
# subscription_thread.start()
