#!/usr/bin/env python3

from typing import Generator, Callable, Dict, List, Any

from flask import Blueprint, request, jsonify, Response, stream_with_context
import threading

import redis

from vulnerabilitylookup.default import get_config
from website.web.bootstrap import csrf


# Define a type alias for a callback function
Callback = Callable[[str], None]

# Create the blueprint
pubsub_bp = Blueprint("pubsub", __name__, url_prefix="/pubsub")
csrf.exempt(pubsub_bp)

# Initialize Valkey/Redis client
redis_client = redis.Redis(
    host=get_config("generic", "storage_db_hostname"),
    port=get_config("generic", "storage_db_port"),
    decode_responses=True,
)

# Default topics
DEFAULT_TOPICS = ['vulnerability', 'comment', 'bundle', 'sighting', 'user']

# Thread-safe dictionary for subscriptions (initialize with default topics)
subscriptions: Dict[str, List[Callback]] = {topic: [] for topic in DEFAULT_TOPICS}


@pubsub_bp.route("/publish", methods=["POST"])
def publish() -> Response | tuple[Response, int]:
    """Publish a message to a topic"""
    data: Any = request.json
    if not data or 'topic' not in data or 'message' not in data:
        return jsonify({'error': 'Invalid payload. "topic" and "message" are required.'}), 400

    topic: str = data['topic']
    message: str = data['message']

    # Ensure topic exists in default topics
    if topic not in subscriptions:
        return jsonify({'error': f"Topic '{topic}' is not available."}), 400

    # Publish the message to the Redis channel
    redis_client.publish(topic, message)
    return jsonify({'message': 'Message published successfully'}), 200


@pubsub_bp.route("/subscribe/<string:topic>", methods=["GET"])
def subscribe(topic: str) -> Response | tuple[Response, int]:
    """Subscribe to a topic and stream messages"""
    if topic not in subscriptions:
        return jsonify({'error': f"Topic '{topic}' is not available."}), 400

    def stream() -> Generator[str, None, None]:
        pubsub = redis_client.pubsub()
        pubsub.subscribe(topic)
        try:
            for message in pubsub.listen():
                if message['type'] == 'message':
                    yield f"data: {message['data']}\n\n"
        except GeneratorExit:
            pubsub.unsubscribe(topic)

    return Response(stream_with_context(stream()), content_type='text/event-stream')


# Background worker for handling subscriptions
def start_subscriber() -> None:
    pubsub = redis_client.pubsub()

    # Only subscribe if there are keys in subscriptions
    if subscriptions:
        pubsub.subscribe(*subscriptions.keys())
    else:
        print("No channels to subscribe to. Waiting for subscriptions...")
        return  # Exit the function as there's nothing to do

    try:
        for message in pubsub.listen():
            if message["type"] == "message":
                topic: str = message["channel"]
                if topic in subscriptions:
                    for callback in subscriptions[topic]:
                        callback(message["data"])
    except redis.exceptions.ResponseError as e:
        print(f"Redis ResponseError: {e}")
    except Exception as e:
        print(f"Unexpected error in subscriber thread: {e}")


# Start the background subscriber in a separate thread
subscription_thread: threading.Thread = threading.Thread(
    target=start_subscriber, daemon=True
)
subscription_thread.start()
