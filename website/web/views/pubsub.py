#!/usr/bin/env python3

from typing import Generator, Callable, Dict, List

import threading

import redis
from flask import abort, Blueprint, request, jsonify, Response, stream_with_context

from vulnerabilitylookup.default import get_config
from website.web.bootstrap import csrf, vulnerabilitylookup


# Define a type alias for a callback function
Callback = Callable[[str], None]

# Create the blueprint
pubsub_bp = Blueprint("pubsub", __name__, url_prefix="/pubsub")
csrf.exempt(pubsub_bp)


# Default topics (ie Redis/Valkey channels)
DEFAULT_TOPICS = get_config("stream", "channels")

# Thread-safe dictionary for subscriptions (initialize with default topics)
subscriptions: Dict[str, List[Callback]] = {topic: [] for topic in DEFAULT_TOPICS}


# @pubsub_bp.route("/publish", methods=["POST"])
# def publish() -> Response | tuple[Response, int]:
#     """Publish a message to a topic"""
#     data: Any = request.json
#     if not data or "topic" not in data or "message" not in data:
#         return (
#             jsonify({"error": 'Invalid payload. "topic" and "message" are required.'}),
#             400,
#         )

#     topic: str = data["topic"]
#     message: str = data["message"]

#     # Ensure topic exists in default topics
#     if topic not in subscriptions:
#         return jsonify({"error": f"Topic '{topic}' is not available."}), 400

#     # Publish the message to the Redis channel
#     vulnerabilitylookup.redis_client.publish(topic, message)
#     return jsonify({"message": "Message published successfully"}), 200


@pubsub_bp.route("/subscribe/<string:topic>", methods=["GET"])
def subscribe(topic: str) -> Response | tuple[Response, int]:
    """Subscribe to a topic and stream messages"""
    if topic not in subscriptions:
        return jsonify({"error": f"Topic '{topic}' is not available."}), 400

    def stream() -> Generator[str, None, None]:
        pubsub = vulnerabilitylookup.redis_client.pubsub()
        try:
            pubsub.subscribe(topic)
        except redis.exceptions.ConnectionError:
            return
        try:
            for message in pubsub.listen():  # type: ignore[no-untyped-call]
                if message["type"] == "message":
                    yield f"data: {message['data']}\n\n"
        except GeneratorExit:
            pubsub.unsubscribe(topic)

    return Response(stream_with_context(stream()), content_type="text/event-stream")


def start_subscriber() -> None:
    """Background worker for handling subscriptions."""
    pubsub = vulnerabilitylookup.redis_client.pubsub()

    # Only subscribe if there are keys in subscriptions
    if subscriptions:
        try:
            pubsub.subscribe(*subscriptions.keys())
        except redis.exceptions.ConnectionError:
            return
    else:
        print("No channels to subscribe to. Waiting for subscriptionsâ€¦")
        return  # Exit the function as there's nothing to do

    try:
        for message in pubsub.listen():  # type: ignore[no-untyped-call]
            if message["type"] == "message":
                topic: str = message["channel"]
                if topic in subscriptions:
                    for callback in subscriptions[topic]:
                        callback(message["data"])
    except redis.exceptions.ResponseError as e:
        print(f"Redis ResponseError: {e}")
    except Exception as e:
        print(f"Unexpected error in subscriber thread: {e}")


# Start the background subscriber in a separate thread
subscription_thread: threading.Thread = threading.Thread(
    target=start_subscriber, daemon=True
)
subscription_thread.start()
