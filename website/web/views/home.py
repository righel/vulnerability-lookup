#!/usr/bin/env python3

from __future__ import annotations

from typing import Any

import sys
import logging
import logging.config
from itertools import islice

from feedgen.feed import FeedGenerator  # type: ignore[import-untyped]
from flask import (
    Blueprint,
    request,
    render_template,
    flash,
    redirect,
    url_for,
    make_response,
    Response,
)
from flask_paginate import get_page_args  # type: ignore[import-untyped]
from sqlalchemy import String, cast, func

from werkzeug import Response as WerkzeugResponse

from vulnerabilitylookup.default import get_config
from vulnerabilitylookup import __version__
from website.models import get_db_info
from website.models import Comment
from website.models import Bundle
from website.models import Sighting
from website.web.bootstrap import application
from website.web.bootstrap import vulnerabilitylookup

logging.config.dictConfig(get_config("logging"))


home_bp = Blueprint("home_bp", __name__, url_prefix="/")

local_instance_name = get_config("generic", "local_instance_name").lower()


@application.errorhandler(404)
def page_not_found(error: Any) -> tuple[str, int]:
    return render_template("errors/404.html"), 404


@application.errorhandler(500)
def internal_server_error_500(error: Any) -> tuple[str, int]:
    return render_template("errors/500.html"), 500


@application.errorhandler(503)
def internal_server_error_503(error: Any) -> tuple[str, int]:
    return render_template("errors/503.html"), 503


# #### Web interface ####


@home_bp.route("/", methods=["GET", "POST"])
@home_bp.route("/search", methods=["GET", "POST"])
def search() -> str | WerkzeugResponse:
    if request.method == "HEAD":
        # Just returns ack if the webserver is running
        return "Ack"
    if request.method == "GET":
        vulnerability_id = request.args.get("vulnerability_id", "").strip()
        vendor = request.args.get("vendor", "").strip()
        product = request.args.get("product", "").strip()
        vulnerability_id = request.args.get("vendor_vuln", "").strip()
    if request.method == "POST":
        vulnerability_id = ""
        product = ""
        vendor = ""
        # trigger search
        if search_query := request.form.get(
            "freetext_search", ""
        ).strip():  # Normal search
            vulnerability_id = search_query
        elif search_query := request.form.get(
            "vendor_vuln", ""
        ).strip():  # Vuln id search from vendor
            vulnerability_id = search_query
            vendor = request.form.get("vendor", "").strip()
        elif search_query := request.form.get(
            "product", ""
        ).strip():  # Search for all vulns related to this vendor and product
            product = search_query
            vendor = request.form.get("vendor", "").strip()

    if vulnerability_id:
        if vulnerabilitylookup.get_vulnerability(vulnerability_id, with_meta=True):
            # The search query was a vulnerability ID, just display that.
            return redirect(
                url_for("home_bp.vulnerability_view", vulnerability_id=vulnerability_id)
            )

        elif linked_vulns := vulnerabilitylookup.get_linked_vulnerabilities(
            vulnerability_id
        ):
            # unable to find a vulnerability with that id. Attempt to find linked entries.
            return render_template(
                "search.html",
                vulnerability_id=vulnerability_id,
                linked_vulns=linked_vulns,
            )
        elif vulnerability_id.lower() in vulnerabilitylookup.get_vendors():
            # FIXME: this is dirty.
            vendor = vulnerability_id
            # Got a vendor, show the proper template.
            vendor_products = vulnerabilitylookup.get_vendor_products(vendor)
            vendor_vulns = vulnerabilitylookup.get_vendor_vulnerabilities(vendor)
            return render_template(
                "search.html",
                vendor=vendor,
                vendor_products=vendor_products,
                vendor_vulns=vendor_vulns,
            )
        flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
    elif vendor and not product:
        if vendor.lower() in vulnerabilitylookup.get_vendors():
            # Got a vendor, show the proper template.
            vendor_products = vulnerabilitylookup.get_vendor_products(vendor)
            vendor_vulns = vulnerabilitylookup.get_vendor_vulnerabilities(vendor)
            return render_template(
                "search.html",
                vendor=vendor,
                vendor_products=vendor_products,
                vendor_vulns=vendor_vulns,
            )
        else:
            flash(f"Nothing found in the database for {vendor}.", "warning")
    elif vendor and product:
        if vulnerabilities := vulnerabilitylookup.get_vendor_product_vulnerabilities(
            vendor, product
        ):
            return render_template(
                "search.html",
                vendor=vendor,
                product=product,
                vp_vulnerabilities=vulnerabilities,
            )
        else:
            flash(f"Nothing found in the database for {vendor} / {product}.", "warning")

    # render search page
    return render_template("search.html")


@home_bp.route("/recent", methods=["GET"])
@home_bp.route("/recent/<int:page>", methods=["GET"])
def recent(page: int = 1) -> str:
    # For the webinterface, we want the most recent entries by source
    sources_to_show = application.config.get("SOURCES_TO_SHOW", {})
    default_source = "cvelistv5"
    recent = {
        source: vulnerabilitylookup.get_last(source, page=page)
        for source in sources_to_show
    }
    try:
        p = int(page)
        if p < 1:
            page = 1
    except ValueError:
        page = 1
    return render_template(
        "recent.html",
        recent=recent,
        default_source=default_source,
        current_page=page,
        local_instance_name=local_instance_name,
        sources_to_show=sources_to_show,
    )


@home_bp.route("/cve/<string:vulnerability_id>", methods=["GET"])
@home_bp.route("/vuln/<string:vulnerability_id>", methods=["GET"])
def vulnerability_view(vulnerability_id: str) -> str | WerkzeugResponse:
    if vulnerability := vulnerabilitylookup.get_vulnerability(
        vulnerability_id, with_meta=True
    ):
        # The search query was a vulnerability ID, just display that.
        source = vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
        linked_vulns = vulnerabilitylookup.get_linked_vulnerabilities(vulnerability_id)
        nb_linked_vulns = sum(len(linked_vulns[source]) for source in linked_vulns)
        nb_comments = Comment.query.filter(
            Comment.vulnerability.ilike(vulnerability_id)
        ).count()
        nb_bundles = Bundle.query.filter(
            func.lower(cast(Bundle.related_vulnerabilities, String)).contains(
                vulnerability_id.lower()
            )
        ).count()
        nb_sightings = Sighting.query.filter(
            Sighting.vulnerability.ilike(vulnerability_id)
        ).count()

        return render_template(
            "vuln.html",
            source=source,
            local_instance_name=local_instance_name,
            vulnerability_id=vulnerability_id,
            vulnerability_data=vulnerability,
            linked_vulns=linked_vulns,
            nb_linked_vulns=nb_linked_vulns,
            nb_comments=nb_comments,
            nb_bundles=nb_bundles,
            nb_sightings=nb_sightings,
        )

    flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
    return redirect(url_for("home_bp.search"))


@home_bp.route("/recent/<string:source>.<string:format>", methods=["GET"])
def feed_recent(
    per_page: int = 10, format: str = "atom", source: str = "all"
) -> Response:
    """RSS/ATOM feed for the rencent vulnerabilities
    per source or for all sources."""
    public_domain = get_config("generic", "public_domain")
    # argument 'vulnerability' is used for the feed of linked vulnerabilities
    vulnerability = request.args.get("vulnerability", "")
    # argument 'vendor' is used to generate a feed of vulnerabilities dedicated a specific vendor
    vendor = request.args.get("vendor", "")
    page, per_page, _ = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    feed_max_per_page = application.config.get("FEED_MAX_PER_PAGE", 50)
    if per_page > feed_max_per_page:
        per_page = feed_max_per_page
    fg = FeedGenerator()
    fg.id(f"https://{public_domain}/rss/recent/{source}/{per_page}")
    fg.title(f"Most recent entries from {source}")
    fg.author(
        {
            "name": "Vulnerability Lookup",
            "email": application.config.get("ADMIN_EMAIL", ""),
        }
    )
    fg.link(href=f"https://{public_domain}", rel="alternate")
    # fg.logo('http://ex.com/logo.jpg')
    fg.subtitle(f"Contains only the most {per_page} recent entries.")
    fg.language("en")
    if source == "all":
        source = ""

    if vulnerability:
        vulnerabilities = [
            vulns[0]
            for _, vulns in vulnerabilitylookup.get_linked_vulnerabilities(
                vulnerability
            ).items()
        ]
    elif vendor:
        # FIXME: improve and return a sorted result
        vendor_vulnerabilities = vulnerabilitylookup.get_vendor_vulnerabilities(vendor)
        vulnerabilities = [
            (vuln_id, vulnerabilitylookup.get_vulnerability(vuln_id, with_meta=False))  # type: ignore[misc]
            for vuln_id in islice(
                vendor_vulnerabilities, (page * per_page) - per_page, (page * per_page)
            )
        ]
    else:
        vulnerabilities = vulnerabilitylookup.get_last(
            source, number=per_page, page=page
        )

    for vuln_id, entry in vulnerabilities:
        fe = fg.add_entry()
        fe.id(f"https://{public_domain}/vuln/{vuln_id}")
        fe.title(vuln_id)
        fe.link(href=f"https://{public_domain}/vuln/{vuln_id}")
        if source in ["github", "pysec", "ossf_malicious_packages"]:
            fe.content(entry["details"])
        elif (
            source == "cvelistv5"
            and "containers" in entry
            and "title" in entry["containers"]["cna"]
        ):
            fe.content(entry["containers"]["cna"]["title"])
        else:
            pass
        fe.description()
    if format == "atom":
        feed = fg.atom_str(pretty=True)
    else:
        feed = make_response(fg.rss_str(pretty=True))
        feed.mimetype = "application/rss+xml"
        feed.headers["Content-Type"] = "application/rss+xml"
    return feed


@home_bp.route("/about", methods=["GET"])
def about() -> str:
    """About page."""
    storage_info = vulnerabilitylookup.get_info()
    return render_template(
        "about.html",
        contact=application.config.get("ADMIN_EMAIL", "#"),
        storage_info=storage_info,
    )


@home_bp.route("/about/more", methods=["GET"])
def about_more() -> str:
    """About page with more technical information about the running instance."""
    storage_info = vulnerabilitylookup.get_info()
    storage_info["db_sizes"].update(get_db_info())
    version = __version__.split("-")
    if len(version) == 1:
        software_version = version[0]
        version_url = (
            "https://github.com/cve-search/vulnerability-lookup/releases/tag/{}".format(
                version[0]
            )
        )
    else:
        software_version = f"{version[0]} - {version[2][1:]}"
        version_url = f"https://github.com/cve-search/vulnerability-lookup/commits/{version[2][1:]}"

    return render_template(
        "about_more.html",
        software_version=software_version,
        version_url=version_url,
        local_instance_uuid=get_config("generic", "local_instance_uuid"),
        registration=[application.config["SELF_REGISTRATION"] and "Open" or "Closed"][
            0
        ],
        moderation=[application.config["COMMENTS_MODERATION"] and "On" or "Off"][0],
        python_version="{}.{}.{}".format(*sys.version_info[:3]),
        storage_info=storage_info,
    )


@home_bp.route("/robots.txt", methods=["GET"])
def robots() -> tuple[str, int, dict[str, str]]:
    """Robots dot txt page."""
    return (
        render_template(
            "robots.txt", contact=application.config.get("ADMIN_EMAIL", "#")
        ),
        200,
        {"Content-Type": "text/plain"},
    )


@home_bp.route("/humans.txt", methods=["GET"])
def humans() -> tuple[str, int, dict[str, str]]:
    """Human dot txt page."""
    return render_template("humans.txt"), 200, {"Content-Type": "text/plain"}


@home_bp.route("/.well-known/security.txt", methods=["GET"])
def security() -> tuple[str, int, dict[str, str]]:
    """security dot txt page (RFC 9116)."""
    return (
        render_template(
            "security.txt", contact=application.config.get("ADMIN_EMAIL", "#")
        ),
        200,
        {"Content-Type": "text/plain"},
    )
