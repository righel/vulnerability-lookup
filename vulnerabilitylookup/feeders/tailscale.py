#!/usr/bin/env python3

from __future__ import annotations

from datetime import datetime
from pathlib import Path
from time import mktime
from typing import Callable

import orjson
import feedparser  # type: ignore[import-untyped]

from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class Tailscale(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        self.files_storage = Path(__file__).parent / self.name
        self.files_storage.mkdir(parents=True, exist_ok=True)
        self.rss_feed = "https://tailscale.com/security-bulletins/index.xml"

    def update(self, stop: Callable[..., bool]) -> bool:
        feed = feedparser.parse(self.rss_feed)
        last_feed_update = datetime.fromtimestamp(mktime(feed.feed.updated_parsed))

        if _last_update := self.storage.hget('last_updates', self.name):
            last_update = fromisoformat_wrapper(_last_update.decode())
            if last_update >= last_feed_update:
                self.logger.info('No updates.')
                return False

        p = self.storage.pipeline()
        tailscaleids: dict[str, float] = {}
        vuln_to_push = []
        for vuln in feed.entries:
            vuln_id = vuln.title.lower()
            last_modified = datetime.fromtimestamp(mktime(vuln.published_parsed))

            tailscaleids[vuln_id] = last_modified.timestamp()
            vuln.pop('published_parsed')
            vuln_bytes = orjson.dumps(vuln)
            vuln_to_push.append(vuln_bytes)
            p.set(vuln_id, vuln_bytes)
        p.zadd(f'index:{self.name}', tailscaleids)  # type: ignore
        p.zadd('index', tailscaleids)  # type: ignore
        p.execute()

        # Publish the vulnerability
        self.publish(vuln_to_push)
        vuln_to_push = []

        self.storage.hset('last_updates', mapping={self.name: last_feed_update.isoformat()})
        self.logger.info('Import done.')
        return True
