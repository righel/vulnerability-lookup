from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import Callable

import orjson

from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder

from pyvariot import PyVARIoT


class VARIoTDB(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        if 'apikey' not in self.config:
            raise Exception('The module requires an API key.')
        self.client = PyVARIoT()
        self.client.apikey = self.config['apikey']

    def update(self, stop: Callable[..., bool]) -> bool:
        last_update: datetime | None = None
        if _last_update_str := self.storage.hget('last_updates', self.name):
            last_update = fromisoformat_wrapper(_last_update_str.decode())

        import_complete: bool = True
        p = self.storage.pipeline()
        pyvariotids: dict[str, float] = {}
        vuln_to_push = []
        for vuln in self.client.get_vulnerabilities_iter(since=last_update, limit=1000):
            vuln_id = vuln['id'].lower()
            last_modified = fromisoformat_wrapper(vuln['last_update_date'])
            pyvariotids[vuln_id] = last_modified.timestamp()
            if 'cve' in vuln and vuln['cve']:
                cve_id = vuln['cve'].lower()
                p.sadd(f"{vuln_id}:link", cve_id)
                p.sadd(f'{cve_id}:link', vuln_id)

            if 'affected_products' in vuln and 'data' in vuln['affected_products']:
                for data in vuln['affected_products']['data']:
                    if data.get('vendor'):
                        vendor = data['vendor'].strip().lower()
                        p.sadd('vendors', vendor)
                        p.sadd(f'{vendor}:vulnerabilities', vuln_id)
                        if data.get('model'):
                            product = data['model'].strip().lower()
                            p.sadd(f'{vendor}:products', product)
                            p.sadd(f'{vendor}:{product}:vulnerabilities', vuln_id)

            vuln_bytes = orjson.dumps(vuln)
            vuln_to_push.append(vuln_bytes)
            p.set(vuln_id, vuln_bytes)

            if len(pyvariotids) > 1000:
                # Avoid a massive execute on first import
                p.zadd(f'index:{self.name}', pyvariotids)  # type: ignore
                p.zadd('index', pyvariotids)  # type: ignore
                p.execute()

                # Publish the vulnerabilities
                self.publish(vuln_to_push)

                # reset pipeline
                p = self.storage.pipeline()
                pyvariotids = {}

                # Reset the list of vulnerabilities to push
                vuln_to_push = []

            if stop():
                self.logger.info('Shutdown requested. Stopping import.')
                import_complete = False
                break

        new_last_update = datetime.now()

        if pyvariotids:
            # remaining entries
            p.zadd(f'index:{self.name}', pyvariotids)  # type: ignore
            p.zadd('index', pyvariotids)  # type: ignore
            p.execute()

            # Publish the vulnerabilities
            self.publish(vuln_to_push)
            vuln_to_push = []

        if import_complete:
            self.storage.hset('last_updates', mapping={self.name: new_last_update.isoformat()})
            self.logger.info('Import done.')
            return True
        return False
