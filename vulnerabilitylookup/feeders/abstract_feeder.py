#!/usr/bin/env python3

from __future__ import annotations

import logging
import logging.config

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Callable

from git import Repo
import orjson
from redis import Redis

from ..default import get_config, get_homedir
from ..helpers import get_config_feeder


class AbstractFeeder(ABC):

    def __init__(self, feeder_name: str):
        self.name = feeder_name
        self._load_logging_config()
        self.logger = logging.getLogger(f'{self.__class__.__name__}')

        self.config = get_config_feeder(self.name)
        if 'level' in self.config:
            self.logger.setLevel(self.config['level'])
        else:
            self.logger.setLevel(get_config('generic', 'loglevel'))

        self.storage = Redis(host=get_config('generic', 'storage_db_hostname'),
                             port=get_config('generic', 'storage_db_port'))

    def _load_logging_config(self) -> None:
        cur_path = Path(__file__)
        if not (cur_path.parent / f'{self.name}_logging.json').exists():
            return
        with (cur_path.parent / f'{self.name}_logging.json').open() as f:
            log_config = orjson.loads(f.read())
        logging.config.dictConfig(log_config)

    def init_git_repo(self) -> None:
        root_repo = Repo(get_homedir())
        root_repo.submodule(self.name).update(init=True)

        self.path_to_repo = get_homedir() / 'vulnerabilitylookup' / 'feeders' / self.name
        self.git = Repo(self.path_to_repo)

    @abstractmethod
    def update(self, stop: Callable[..., bool]) -> bool:
        ...

    def publish(self, message: bytes | list[bytes] | list[str], channel: str='vulnerability') -> None:
        """Publish ``message`` on ``channel``. By default on the ``vulnerability`` channel."""
        if isinstance(message, list):
            for elem in message:
                self.storage.publish(channel, elem)
        else:
            self.storage.publish(channel, message)
