#!/usr/bin/env python3

from __future__ import annotations

import json
import logging

from collections import defaultdict
from typing import Any, Generator

from redis import ConnectionPool, Redis
from redis.connection import UnixDomainSocketConnection

from .default import get_config, get_socket_path


class VulnerabilityLookup():

    def __init__(self) -> None:
        self.logger = logging.getLogger(f'{self.__class__.__name__}')
        self.logger.setLevel(get_config('generic', 'loglevel'))

        self.redis_pool: ConnectionPool = ConnectionPool(connection_class=UnixDomainSocketConnection,
                                                         path=get_socket_path('cache'), decode_responses=True)

        self.redis_pool_storage: ConnectionPool = ConnectionPool(
            host=get_config('generic', 'storage_db_hostname'),
            port=get_config('generic', 'storage_db_port'),
            decode_responses=True)

    @property
    def storage(self) -> Redis:  # type: ignore[type-arg]
        return Redis(connection_pool=self.redis_pool_storage)

    @property
    def redis(self) -> Redis:  # type: ignore[type-arg]
        return Redis(connection_pool=self.redis_pool)

    @property
    def redis_client(self) -> Redis:  # type: ignore[type-arg]
        return Redis(
            host=get_config("generic", "storage_db_hostname"),
            port=get_config("generic", "storage_db_port"),
            decode_responses=True,
        )

    def check_redis_up(self) -> bool:
        return self.redis.ping()

    def get_vulnerability_meta(self, vulnerability_id: str) -> dict[str, str | dict[str, Any]]:
        _vid = vulnerability_id.lower()
        to_return: dict[str, str | dict[str, Any]] = {}
        for meta_name, meta_uuid in self.storage.hgetall(f'{_vid}:meta').items():
            if self.storage.exists(f'{meta_name}:{meta_uuid}'):
                if self.storage.type(f'{meta_name}:{meta_uuid}') == 'string':  # type: ignore[no-untyped-call]  # noqa
                    if _meta_str := self.storage.get(f'{meta_name}:{meta_uuid}'):
                        to_return[meta_name] = _meta_str
                elif self.storage.type(f'{meta_name}:{meta_uuid}') == 'hash':  # type: ignore[no-untyped-call]  # noqa
                    if _meta_hash := self.storage.hgetall(f'{meta_name}:{meta_uuid}'):
                        to_return[meta_name] = _meta_hash
            else:
                self.logger.warning(f'Unable to find meta {meta_uuid} for {meta_name}')
        return to_return

    def get_linked_vulnerabilities(self, vulnerability_id: str) -> dict[str, list[tuple[str, dict[str, Any]]]]:
        _vid = vulnerability_id.lower()
        to_return: dict[str, list[tuple[str, dict[str, Any]]]] = defaultdict(list)
        for linked_vuln in self.storage.smembers(f'{_vid}:link'):
            if vuln := self.get_vulnerability(linked_vuln):
                if source := self.get_vulnerability_source(linked_vuln):
                    to_return[source].append((linked_vuln, vuln))
                else:
                    self.logger.warning(f'Unable to find source for {linked_vuln}')
        return to_return

    def get_vulnerability_source(self, vulnerability_id: str) -> str | None:
        _vid = vulnerability_id.lower()
        for source in self.storage.hkeys('last_updates'):
            if self.storage.zscore(f'index:{source}', _vid):
                return source
        return None

    def get_vulnerability(self, vulnerability_id: str,
                          *, with_meta: bool | None=False) -> dict[str, Any] | None:
        _vid = vulnerability_id.lower()
        _vuln = self.storage.get(_vid)
        if not _vuln:
            return None
        vuln = json.loads(_vuln)
        if with_meta:
            if meta := self.get_vulnerability_meta(_vid):
                vuln['meta'] = meta
        return vuln

    def get_sources(self) -> set[str]:
        last_updates = self.storage.hgetall('last_updates')
        return {name for name in last_updates.keys()}

    def del_source(self, source: str) -> int:
        return self.storage.hdel('last_updates', source)

    def get_info(self) -> dict[str, Any]:
        last_updates = self.storage.hgetall('last_updates')

        sizes = {name: self.storage.zcard(f'index:{name}') for name in last_updates.keys()}
        sizes['total'] = self.storage.zcard('index')

        return {'last_updates': last_updates, 'db_sizes': sizes}

    def get_last(self, source: str | None=None, number: int | None=30, page: int | None=None) -> list[tuple[str, dict[str, Any]]]:
        key = 'index'
        if source:
            key = f'{key}:{source}'
        if not number:
            number = 30
        if page is None or page < 1:
            page = 1

        start = (page - 1) * number
        to_return = []
        for vuln_id in self.storage.zrevrangebyscore(key, '+Inf', '-Inf', start=start, num=number):
            if vuln := self.get_vulnerability(vuln_id):
                to_return.append((vuln_id, vuln))
        return to_return

    def get_all(self, source: str = "", /, with_meta: bool=False) -> Generator[dict[str, Any], None, None]:
        """This method will scan a complete source and yield the vulnerabilities.
        It is up to the caller to handle the yielded entries as it will be a lot"""
        if source:
            key = f'index:{source}'
        else:
            key = 'index'
        for vuln_id, _ in self.storage.zscan_iter(key):
            if vuln := self.get_vulnerability(vuln_id, with_meta=with_meta):
                yield vuln

    def get_vendors(self) -> set[str]:
        return self.storage.smembers('vendors')

    def get_vendor_products(self, vendor: str) -> set[str]:
        _v = vendor.strip().lower()
        return self.storage.smembers(f'{_v}:products')

    def get_vendor_vulnerabilities(self, vendor: str) -> set[str]:
        _v = vendor.strip().lower()
        return self.storage.smembers(f'{_v}:vulnerabilities')

    def get_vendor_product_vulnerabilities(self, vendor: str, product: str) -> dict[str, list[tuple[str, dict[str, Any]]]]:
        _v = vendor.strip().lower()
        _p = product.strip().lower()
        to_return: dict[str, list[tuple[str, dict[str, Any]]]] = defaultdict(list)
        for vuln_id in self.storage.smembers(f'{_v}:{_p}:vulnerabilities'):
            if vuln := self.get_vulnerability(vuln_id):
                if source := self.get_vulnerability_source(vuln_id):
                    to_return[source].append((vuln_id, vuln))
                else:
                    self.logger.warning(f'Unable to find source for {vuln_id}')
        return to_return
